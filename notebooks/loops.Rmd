---
title: "Loop Analysis for 16p"
author: "Siddharth Reed"
date: "`r Sys.Date()`"
---
<style type="text/css">
.main-container {
  max-width: 1800px !important;
  margin-left: auto;
  margin-right: auto;
}
</style>

# Set Up

```{r knitr}
library(knitr)
knitr::opts_chunk$set(
    results=FALSE,
    message=FALSE,
    warning=FALSE,
    dev=c('png', 'pdf', 'svg'),
    dpi=300
)
```
Set up file locations + load dependences
```{r dependencies}
library(here)
# library(ggplot2)
# library(ggh4x)
# library(GGally)
# library(ComplexUpset)
here::i_am('notebooks/loops.Rmd')
BASE_DIR <- here()
source(file.path(BASE_DIR, 'scripts/locations.R'))
source(file.path(SCRIPT_DIR, 'utils.data.R'))
source(file.path(BASE_DIR, 'scripts/constants.R'))
source(file.path(SCRIPT_DIR, 'utils.plot.R'))
source(file.path(SCRIPT_DIR, 'utils.annotations.R'))
source(file.path(SCRIPT_DIR, 'loops/utils.loops.R'))
library(tidyverse)
library(magrittr)
```

# Load Loop Annotations

Using the default params we only keep loops < 2Mb in size, which is enough to capture most CTCF-associated loops in human cells. The loop calling params are explained in the [cooltools docs](https://cooltools.readthedocs.io/en/latest/notebooks/dots.html#Dot-calling-with-default-parameters):

- A set of convolution kernels are recommended based on the resolution of clr, if user-defined convolution kernels are not provided (i.e. kernels=None).
- The requested portion of the heatmap (defined by view_df and max_loci_separation) is split into smaller tiles of size tile_size. This ensures the entire heatmap is not loaded into memory at once, and computationally intensive steps can be done in parallel using nproc workers. tile_size and nproc do not affect the outcome of the procedure.
- Tiles of the heatmap are convolved with the provided kernels to calculate localy adjusted expected for each pixel. This is in turn used to calculate p-values, assuming a Poisson distribution of pixel counts.
- Pixels are assigned to geometrically-spaced “lambda-bins” of locally-adjusted expected for statistical testing. Within each lambda-bin, signficantly enriched pixels are “caled” using BH-FDR multiple hypothesis testing procedure, and thresholds of significance are calculated for each lambda-bin and each kernel-type (controlled by lambda_bin_fdr).
- Significantly-enriched pixels are extracted, based on the thresholds in each lambda bin. Note the cooltools implementation of this step involves a second pass with the same convolution kernels to re-score pixels, as this is less costly than storing all such scores in memory.
- Additional clustering and empirical filtering is optionally performed (depending on clustering_radius and cluster_filtering).

Load all cooltools loop annotations, only keep 1 kernel (donut)
```{r load_loops}
# this is applied to the donut kernel, but all loops are significant with
# all kernels if sig with donut kernel
q.thresh <- 0.1 
loops.df <- 
    check_cached_results(
        results_file=COOLTOOLS_LOOPS_RESULTS_FILE,
        # force_redo=TRUE,
        results_fnc=load_all_cooltools_dots
    ) %>%
    post_process_cooltools_dots_results() %>% 
    filter(weight == 'balanced') %>% 
    # filter(resolution == 10000) %>% 
    filter(kernel == 'donut') %>% 
    filter(log10.qval > -log10(q.thresh)) %>% 
    standardize_data_cols()
```
Load annotation data
```{r load_annotation_data}
# chr.sizes.df <- load_chr_sizes()
# functional.annotations.df <- load_functional_annotations()
# annotations.df <- 
#     FUNCTIONAL_ANNOTATION_FILES %>%
#     {.[1]} %>%
#     read_tsv()
# annotations.df
# abcs.df <- 
#     ABC_ANNOTATIONS_FILE %>%
#     read_tsv()
```

# Number of Loops {.tabset}

```{r n_loops}
n.loops.per.chr.df <- 
    loops.df %>%
    # cumulative number of loops at different threshold
    mutate(
        'sig.lvl.qval < 0.000001'=log10.qval > -log10(0.000001),
        'sig.lvl.qval < 0.001'=log10.qval > -log10(0.001),
        'sig.lvl.qval < 0.1'=log10.qval > -log10(0.1),
        'sig.lvl.N.S.'=log10.qval <= -log10(0.1)
    ) %>% 
    select(
        # type, isMerged, 
        weight, resolution, 
        SampleID, 
        chr,
        kernel,
        starts_with('sig.lvl.')
    ) %>% 
    pivot_longer(
        starts_with('sig.lvl.'),
        names_to='sig.lvl',
        names_prefix='sig.lvl.',
        values_to='meet.sig.lvl'
    ) %>% 
    filter(meet.sig.lvl) %>% 
    mutate(
        sig.lvl=
            factor(
                sig.lvl,
                levels=
                    c(
                        'qval < 0.000001',
                        'qval < 0.001',
                        'qval < 0.1',
                        'N.S.'
                    )
            )
    ) %>% 
    count(
        # type, isMerged, 
        weight, resolution, 
        SampleID, 
        chr,
        kernel,
        sig.lvl,
        name='n.loops'
    )
```

## Genome-Wide

```{r plot_n_loops_heatmap_gw, results='asis', fig.dim=c(10,6)}
n.loops.per.chr.df %>% 
    group_by(across(-c(chr, n.loops))) %>% 
    summarize(n.loops=sum(n.loops)) %>%
    ungroup() %>%
    add_column(chr='Genome-Wide') %>% 
    separate_wider_delim(
        SampleID,
        delim='.',
        names=c(NA, 'Celltype', 'Genotype'),
        cols_remove=FALSE
    ) %>%
    # filter(kernel == 'donut') %>% 
    # filter(resolution == '25Kb') %>% 
    filter(sig.lvl %in% c('qval < 0.1', 'N.S.')) %>% 
    make_nested_plot_tabs(
        # group.cols=c('type', 'isMerged', 'weight', 'resolution'),
        group.cols=c('weight', 'resolution'),
        plot.fnc=plot_barplot,
        max.header.lvl=3,
        x.var='SampleID',
        y.var='n.loops',
        fill.var='SampleID', 
        facet.row='sig.lvl',
        facet.col='Celltype',
        legend.position='right',
        scales='free_x',
        # axis.text.x=element_text(angle=45, hjust=1),
        # legend.text=element_text(angle=35, hjust=1),
        axis.title.x=element_blank(),
        axis.title.y=element_blank()
    )
```

## Per Chr

```{r plot_n_loops_heatmap_chr, results='asis', fig.dim=c(10,6)}
n.loops.per.chr.df %>% 
    separate_wider_delim(
        SampleID,
        delim='.',
        names=c(NA, 'Celltype', 'Genotype'),
        cols_remove=FALSE
    ) %>%
    # filter(kernel == 'donut') %>% 
    # filter(resolution == '25Kb') %>% 
    filter(sig.lvl %in% c('qval < 0.1', 'N.S.')) %>% 
    make_nested_plot_tabs(
        # group.cols=c('type', 'isMerged', 'weight', 'resolution'),
        group.cols=c('weight', 'resolution'),
        plot.fnc=plot_barplot,
        max.header.lvl=3,
        x.var='chr',
        x.scale.mode='discrete',
        y.var='n.loops',
        fill.var='SampleID', 
        facet.col='sig.lvl',
        facet.row='Celltype',
        legend.position='right',
        axis.text.x=element_text(angle=45, hjust=1),
        axis.title.x=element_blank(),
        axis.title.y=element_blank()
    )
```

# Size of Loops {.tabset}

Plot size distribution of loops
```{r plot_loop_size_violin, results='asis', fig.dim=c(10,6)}
loops.df %>% 
    # filter(kernel == 'donut') %>% 
    # filter(resolution == '25Kb') %>% filter(weight == 'raw') %>% 
    make_nested_plot_tabs(
        # group.cols=c('type', 'isMerged', 'weight', 'resolution'),
        group.cols=c('weight', 'resolution'),
        max.header.lvl=2,
        plot.fnc=plot_boxplot,
        # quantile.linetype=TRUE,
        x.var='chr',
        # x.scale.mode='discrete',
        y.var='length',
        y.scale.mode='mb',
        fill.var='SampleID', 
        facet.row='kernel',
        legend.position='right',
        outlier.size=0.25,
        axis.text.x=element_text(angle=45, hjust=1),
        # legend.text=element_text(angle=35, hjust=1),
        axis.title.x=element_blank(),
        axis.title.y=element_blank()
    )
```

# Distribution Plots {.tabset}

Make violin plot with q-values
```{r box_plot, results='asis', fig.dim=c(10,6)}
loops.df %>% 
    pivot_longer(
        c('enrichment', 'log10.qval'),
        names_to='metric', 
        values_to='value'
    ) %>% 
    make_nested_plot_tabs(
        # group.cols=c('type', 'isMerged', 'weight', 'resolution'),
        group.cols=c('weight', 'resolution'),
        max.header.lvl=2,
        plot.fnc=plot_boxplot,
        x.var='chr',
        x.scale.mode='discrete',
        y.var='value',
        fill.var='SampleID',
        # plot_pts=TRUE,
        # facet.col='kernel',
        facet.row='metric',
        scales='free_y',
        outlier.size=0.25,
        strip.text.x=element_text(size=5),
        axis.text.x=element_text(angle=45, hjust=1)
    )
```

# Manhattan Plots {.tabset}

Make manhattan plot with q-values
```{r manhattan_plot, results='asis', fig.dim=c(10,6)}
loops.df %>% 
    make_nested_plot_tabs(
        # group.cols=c('type', 'isMerged', 'weight', 'resolution'),
        group.cols=c('weight', 'resolution'),
        max.header.lvl=2,
        plot.fnc=plot_jitter,
        # x.var='SampleID',
        # y.var='log10.qval',
        # color.var='Genotype',
        # shape.var='Genotype',
        x.var='chr',
        y.var='log10.qval',
        color.var='enrichment',
        facet.row='SampleID',
        size=0.25,
        axis.title.x=element_blank(),
        axis.text.x=element_text(angle=45, hjust=1)
    )
```

# Volcano-ish plot Plots {.tabset}

## Genome-Wide {.tabset}

```{r volcanoish_gw, results='asis', fig.dim=c(10,8)}
loops.df %>% 
    # filter(weight == 'raw', resolution == '10Kb') %>% 
    make_nested_plot_tabs(
        # group.cols=c('type', 'isMerged', 'weight', 'resolution'),
        # group.cols=c('weight', 'resolution', 'metric', 'kernel'),
        group.cols=c('weight', 'resolution', 'kernel'),
        max.header.lvl=3,
        plot.fnc=plot_jitter,
        x.var='enrichment',
        y.var='log10.qval',
        color.var='SampleID',
        regression_fnc='lm',
        add_regression_SE=TRUE,
        # facet.group='chr',
        # facet.nrow=4,
        scales='fixed',
        legend.position='right',
        # size=0.25,
        axis.text.x=element_text(angle=45, hjust=1)
    )
```

## Per Chr {.tabset}

```{r volcanoish_chr, results='asis', fig.dim=c(10,6)}
loops.df %>% 
    # filter(weight == 'raw', resolution == '10Kb') %>% 
    make_nested_plot_tabs(
        # group.cols=c('type', 'isMerged', 'weight', 'resolution'),
        # group.cols=c('weight', 'resolution', 'metric', 'kernel'),
        group.cols=c('weight', 'resolution', 'kernel'),
        max.header.lvl=3,
        plot.fnc=plot_jitter,
        x.var='enrichment',
        y.var='log10.qval',
        color.var='SampleID',
        regression_fnc='lm',
        add_regression_SE=TRUE,
        facet.group='chr',
        facet.nrow=4,
        scales='fixed',
        # legend.position='top',
        # size=0.25,
        strip.text=element_text(size=8),
        axis.text.x=element_text(angle=45, hjust=1)
    )
```

# IDR2D Analysis  {.tabset}

```{r load_idr2d}
# Generate IDR2D results for all comparisons of sample groups
idr2d.results.df <- 
    check_cached_results(
        results_file=LOOPS_IDR2D_RESULTS_FILE,
        # force_redo=TRUE,
        results_fnc=load_all_IDR2D_results
    ) %>% 
    # filter(weight == 'balanced') %>%
    # filter(resolution == 10000) %>% 
    # filter(resolve.method == 'value') %>% 
    # filter(metric == 'log10.qval') %>% 
    mutate(comparison=glue('{SampleID.P1} vs {SampleID.P2}')) %>% 
    mutate(
        is.loop.shared=
            case_when(
                loop.type == 'P1.only' ~ loop.type,
                loop.type == 'P2.only' ~ loop.type,
                IDR <= 0.1             ~ 'IDR < 0.1',
                IDR <= 1               ~ 'Irreproducible',
                TRUE                   ~ NA
            )
    ) %>%
    standardize_data_cols()
```

## Compare resolving strategies + metrics {.tabset}

```{r idr2d_hyperparams_heatmap, results='asis', fig.dim=c(10,6), eval=FALSE}
idr2d.results.df %>% 
    count(
        weight, resolution, kernel,
        resolve.method, metric,
        comparison, 
        # SampleID.P1, SampleID.P2,
        # chr,
        is.loop.shared
    ) %>% 
    make_nested_plot_tabs(
        max.header.lvl=3,
        # group.cols=c('resolution', 'comparison'),
        # group.cols=c('weight', 'resolution', 'kernel'),
        group.cols=c('weight', 'resolution'),
        # plot.fnc=plot_density,
        plot.fnc=plot_heatmap,
        x.var='metric',
        y.var='resolve.method',
        fill.var='n',
        label.var='n',
        facet.row='is.loop.shared',
        facet.col='comparison',
        scales='fixed',
        legend.position='right',
        fill.scale.mode='m',
        strip.text=element_text(size=10),
        axis.text.x=element_text(angle=45, hjust=1),
        axis.title.x=element_blank(),
        axis.title.y=element_blank()
    )
```

## Reproducible loops Heatmaps {.tabset}

### Genome-Wide

```{r idr2d_hyperparams_boxplot_gw, results='asis', fig.dim=c(8,8)}
idr2d.results.df %>% 
    filter(resolve.method == 'value') %>% 
    filter(metric == 'log10.qval') %>% 
    count(
        weight, resolution, kernel,
        # resolve.method, metric,
        comparison, 
        SampleID.P1, SampleID.P2,
        # chr,
        is.loop.shared
    ) %>% 
    make_nested_plot_tabs(
        max.header.lvl=4,
        group.cols=c('weight', 'resolution'),
        plot.fnc=plot_heatmap,
        y.var='comparison',
        x.var='is.loop.shared',
        fill.var='n',
        label.var='n',
        label.size=5,
        # facet.group='chr',
        # facet.ncol=6,
        # facet.row='SampleID.P1',
        # facet.col='SampleID.P2',
        scales='fixed',
        legend.position='right',
        fill.scale.mode='m',
        strip.text=element_text(size=10),
        axis.text.x=element_text(angle=45, hjust=1),
        axis.title.x=element_blank(),
        axis.title.y=element_blank()
    )
```

### Per Chr

```{r idr2d_hyperparams_boxplot_chr, results='asis', fig.dim=c(10,6)}
idr2d.results.df %>% 
    filter(resolve.method == 'value') %>% 
    filter(metric == 'log10.qval') %>% 
    count(
        weight, resolution, kernel,
        # resolve.method, metric,
        comparison, 
        SampleID.P1, SampleID.P2,
        chr,
        is.loop.shared
    ) %>% 
    make_nested_plot_tabs(
        max.header.lvl=4,
        group.cols=c('weight', 'resolution'),
        plot.fnc=plot_heatmap,
        y.var='comparison',
        x.var='is.loop.shared',
        fill.var='n',
        label.var='n',
        label.size=3,
        facet.group='chr',
        facet.ncol=6,
        # facet.row='SampleID.P1',
        # facet.col='SampleID.P2',
        scales='fixed',
        legend.position='right',
        fill.scale.mode='m',
        strip.text=element_text(size=10),
        axis.text.x=element_text(angle=45, hjust=1),
        axis.title.x=element_blank(),
        axis.title.y=element_blank()
    )
```

## Reproducible loops Barplot {.tabset}

### Genome-Wide

```{r idr2d_hyperparams_barplot_gw, results='asis', fig.dim=c(10,8)}
idr2d.results.df %>% 
    filter(resolve.method == 'value') %>% 
    filter(metric == 'log10.qval') %>% 
    count(
        weight, resolution, kernel,
        # resolve.method, metric,
        comparison, 
        SampleID.P1, SampleID.P2,
        # chr,
        is.loop.shared
    ) %>% 
    make_nested_plot_tabs(
        max.header.lvl=4,
        group.cols=c('weight', 'resolution'),
        plot.fnc=plot_barplot,
        x.var='is.loop.shared',
        y.var='n',
        fill.var='comparison',
        facet.row='Celltype',
        # facet.group='chr',
        # facet.ncol=6,
        # facet.row='SampleID.P1',
        # facet.col='SampleID.P2',
        scales='fixed',
        legend.position='right',
        y.scale.mode='m',
        axis.text.x=element_text(angle=45, hjust=1),
        axis.title.x=element_blank(),
        axis.title.y=element_blank()
    )
```

### Per Chr

```{r idr2d_hyperparams_barplot_chr, results='asis', fig.dim=c(10,6)}
idr2d.results.df %>% 
    filter(resolve.method == 'value') %>% 
    filter(metric == 'log10.qval') %>% 
    count(
        weight, resolution, kernel,
        # resolve.method, metric,
        comparison, 
        SampleID.P1, SampleID.P2,
        chr,
        is.loop.shared
    ) %>% 
    make_nested_plot_tabs(
        max.header.lvl=4,
        group.cols=c('weight', 'resolution'),
        plot.fnc=plot_heatmap,
        x.var='chr',
        y.var='n',
        fill.var='comparison',
        facet.row='Celltype',
        scales='fixed',
        legend.position='right',
        y.scale.mode='m',
        strip.text=element_text(size=10),
        axis.text.x=element_text(angle=45, hjust=1),
        axis.title.x=element_blank(),
        axis.title.y=element_blank()
    )
```

# Compare Expression of Genes to Loops

Load expression data
```{r load_expr_and_map_to_loops, eval=FALSE}
expression.df <- 
    load_gene_expression_data() %>%
    filter(feature == "protein_coding") %>% 
    # pivot_longer(
    #     starts_with('TPM.'),
    #     names_to='metric',
    #     values_to='value',
    # ) %>% 
    # pivot_wider(
    #     names_from=SampleID,
    #     values_from=value
    # ) %>% 
    select(-c(feature))
loop.expr.df <- 
    idr2d.results.df %>% 
    filter(resolve.method == 'value') %>% 
    filter(metric == 'log10.qval') %>% 
    select(-c(metric, resolve.method)) %>% 
    join_expr_and_IDR2D_results(expression.df) %>% 
    select(
        -c(
            # comparison,
            diff.value, diff.rank, 
            loop.type,
            # metric, resolve.method
            # IDR, is.loop.shared
        )
    )
# rm(expression.df)
```

## Plot expression of genes between loops  {.tabset}

```{r plot_expr_of_loops, results='asis', fig.dim=c(10,6), eval=FALSE}
# tmp <- 
#     idr2d.results.df %>% 
#     filter(resolve.method == 'overlap') %>% 
#     filter(metric == 'log10.qval') %>% 
#     filter(weight == 'balanced', resolution == '10Kb', kernel == 'donut') %>% 
#     count(chr, is.loop.shared, SampleID.P1, SampleID.P2) %>% 
#     pivot_wider(names_from=is.loop.shared, values_from=n)
# tmp %>% filter(chr == 'chr16')
# tmp %>% filter(chr %in% c('chr10', 'chr16'))
loop.expr.df %>% 
    filter(weight == 'balanced', resolution == '10Kb', kernel == 'donut') %>% 
    filter(TPM.mean < 200) %>% 
    filter(TPM.mean > 50) %>% 
    make_nested_plot_tabs(
        max.header.lvl=3,
        group.cols=c('weight', 'resolution', 'comparison'),
        plot.fnc=plot_boxplot,
        # x.var='chr',
        x.var='is.loop.shared',
        x.scale.mode='discrete',
        y.var='TPM.mean',
        fill.var='SampleID',
        # fill.var='SampleID',
        fill.scale.mode='discrete',
        # label.var='',
        # facet.group='chr',
        # facet.ncol=6,
        # facet.row='is.loop.shared',
        # facet.col='is.loop.shared',
        scales='free_y',
        legend.position='right',
        # fill.scale.mode='m',
        strip.text=element_text(size=10),
        axis.text.x=element_text(angle=45, hjust=1),
        axis.title.x=element_blank(),
        axis.title.y=element_blank()
    )
```

## Find differential genes

# Compare Loops across Genotypes {.tabset}

## Plot anchor differences boxplot {.tabset}

```{r plot_compare_anchors_boxplot, results='asis', fig.dim=c(10,6), eval=FALSE}
diff.df %>% 
    # filter(!metric %in% c('start', 'end', 'length')) %>% 
    filter(metric %in% c('length', 'enrichment', 'log10_qval')) %>% 
    mutate(diff=abs(diff)) %>% 
    make_nested_plot_tabs(
        group.cols=c('weight', 'resolution'),
        max.header.lvl=3,
        plot.fnc=plot_boxplot,
        x.var='chr',
        y.var='diff',
        fill.var='SampleID',
        facet.row='metric',
        x.scale.mode='discrete',
        scales='free_y',
        legend.position='top',
        axis.title.x=element_blank(),
        strip.text=element_text(size=20),
        axis.text.x=element_text(angle=45, hjust=1)
    )
```

## Plot anchor differences scatter {.tabset}

```{r plot_compare_anchors_scatter, results='asis', fig.dim=c(10,6), eval=FALSE}
diff.df %>% 
    # filter(metric %in% c(start, end, length)) %>% 
    # filter(!metric %in% c('start', 'end', 'length')) %>% 
    filter(metric %in% c('enrichment', 'log10_qval')) %>% 
    make_nested_plot_tabs(
        group.cols=c('weight', 'resolution'),
        max.header.lvl=3,
        plot.fnc=plot_jitter,
        x.var='P1',
        y.var='P2',
        color.var='SampleID',
        # facet.row='metric',
        facet.group='metric',
        facet.ncol=1,
        scales='free',
        size=0.75,
        legend.position='top',
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        strip.text=element_text(size=20),
        axis.text.x=element_text(angle=45, hjust=1)
    )
```

## Plot Anchor MoCs {.tabset}

```{r plot_compare_anchors_MoC, results='asis', fig.dim=c(10,6), eval=FALSE}
similarity.df %>% 
    # select(-c(ends_with('diff'))) %>% 
    group_by(weight, resolution, chr, kernel, SampleID) %>%
    summarize(MoC=(sum(moc.inner) - 1) * unique(MoC.norm)) %>% 
    ungroup() %>% 
    make_nested_plot_tabs(
        # group.cols=c('type', 'isMerged', 'weight', 'resolution'),
        group.cols=c('weight', 'resolution'),
        max.header.lvl=3,
        plot.fnc=plot_barplot,
        x.var='chr',
        y.var='MoC',
        # color.var='Genotype',
        # shape.var='Genotype',
        # x.var='Genotype',
        fill.var='SampleID',
        # facet.col='chr',
        # facet.row='context',
        x.scale.mode='discrete',
        # y.scale.mode='mb',
        # scales='free_y',
        # size=0.25,
        legend.position='top',
        axis.title.x=element_blank(),
        axis.text.x=element_text(angle=45, hjust=1)
    )
```

# Plot against genome annotations

## Plot loops against CTCF sites

## Plot against CNVs?

