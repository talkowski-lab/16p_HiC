---
title: "Loop Analysis for 16p"
author: "Siddharth Reed"
date: "`r Sys.Date()`"
---
<style type="text/css">
.main-container {
  max-width: 1800px !important;
  margin-left: auto;
  margin-right: auto;
}
</style>

# Set Up

```{r knitr}
library(knitr)
knitr::opts_chunk$set(
    results=FALSE,
    message=FALSE,
    warning=FALSE,
    dev=c('png', 'pdf', 'svg'),
    dpi=300
)
```
Set up file locations + load dependences
```{r dependencies}
library(here)
# library(ggplot2)
# library(ggh4x)
# library(GGally)
# library(ComplexUpset)
here::i_am('notebooks/loops.Rmd')
BASE_DIR <- here()
source(file.path(BASE_DIR, 'scripts/locations.R'))
source(file.path(SCRIPT_DIR, 'utils.data.R'))
source(file.path(BASE_DIR, 'scripts/constants.R'))
source(file.path(SCRIPT_DIR, 'utils.plot.R'))
source(file.path(SCRIPT_DIR, 'utils.annotations.R'))
source(file.path(SCRIPT_DIR, 'loops/utils.loops.R'))
library(tidyverse)
library(magrittr)
```

# Load Loop Annotations

Using the default params we only keep loops < 2Mb in size, which is enough to capture most CTCF-associated loops in human cells. The loop calling params are explained in the [cooltools docs](https://cooltools.readthedocs.io/en/latest/notebooks/dots.html#Dot-calling-with-default-parameters):

- A set of convolution kernels are recommended based on the resolution of clr, if user-defined convolution kernels are not provided (i.e. kernels=None).
- The requested portion of the heatmap (defined by view_df and max_loci_separation) is split into smaller tiles of size tile_size. This ensures the entire heatmap is not loaded into memory at once, and computationally intensive steps can be done in parallel using nproc workers. tile_size and nproc do not affect the outcome of the procedure.
- Tiles of the heatmap are convolved with the provided kernels to calculate localy adjusted expected for each pixel. This is in turn used to calculate p-values, assuming a Poisson distribution of pixel counts.
- Pixels are assigned to geometrically-spaced “lambda-bins” of locally-adjusted expected for statistical testing. Within each lambda-bin, signficantly enriched pixels are “caled” using BH-FDR multiple hypothesis testing procedure, and thresholds of significance are calculated for each lambda-bin and each kernel-type (controlled by lambda_bin_fdr).
- Significantly-enriched pixels are extracted, based on the thresholds in each lambda bin. Note the cooltools implementation of this step involves a second pass with the same convolution kernels to re-score pixels, as this is less costly than storing all such scores in memory.
- Additional clustering and empirical filtering is optionally performed (depending on clustering_radius and cluster_filtering).

Load all cooltools loop annotations, only keep 1 kernel (donut)
```{r load_loops}
# this is applied to the donut kernel, but all loops are significant with
# all kernels if sig with donut kernel
q.thresh <- 0.1 
loops.df <- 
    check_cached_results(
        results_file=COOLTOOLS_LOOPS_RESULTS_FILE,
        # force_redo=TRUE,
        results_fnc=load_all_cooltools_dots
    ) %>%
    post_process_cooltools_dots_results() %>% 
    filter(weight == 'balanced') %>% 
    # filter(resolution == 10000) %>% 
    filter(kernel == 'donut') %>% 
    filter(log10.qval > -log10(q.thresh)) %>% 
    standardize_data_cols()
```
Load annotation data
```{r load_annotation_data}
# chr.sizes.df <- load_chr_sizes()
expression.df <- load_gene_expression_data()
# functional.annotations.df <- load_functional_annotations()
# annotations.df <- 
#     FUNCTIONAL_ANNOTATION_FILES %>%
#     {.[1]} %>%
#     read_tsv()
# annotations.df
# abcs.df <- 
#     ABC_ANNOTATIONS_FILE %>%
#     read_tsv()
```

# Number of Loops {.tabset}

```{r n_loops}
n.loops.per.chr.df <- 
    loops.df %>%
    # cumulative number of loops at different threshold
    mutate(
        'sig.lvl.qval < 0.000001'=log10.qval > -log10(0.000001),
        'sig.lvl.qval < 0.001'=log10.qval > -log10(0.001),
        'sig.lvl.qval < 0.1'=log10.qval > -log10(0.1),
        'sig.lvl.N.S.'=log10.qval <= -log10(0.1)
    ) %>% 
    select(
        # type, isMerged, 
        weight, resolution, 
        SampleID, 
        chr,
        kernel,
        starts_with('sig.lvl.')
    ) %>% 
    pivot_longer(
        starts_with('sig.lvl.'),
        names_to='sig.lvl',
        names_prefix='sig.lvl.',
        values_to='meet.sig.lvl'
    ) %>% 
    filter(meet.sig.lvl) %>% 
    mutate(
        sig.lvl=
            factor(
                sig.lvl,
                levels=
                    c(
                        'qval < 0.000001',
                        'qval < 0.001',
                        'qval < 0.1',
                        'N.S.'
                    )
            )
    ) %>% 
    count(
        # type, isMerged, 
        weight, resolution, 
        SampleID, 
        chr,
        kernel,
        sig.lvl,
        name='n.loops'
    )
```

## Genome-Wide

```{r plot_n_loops_heatmap_gw, results='asis', fig.dim=c(10,6)}
n.loops.per.chr.df %>% 
    group_by(across(-c(chr, n.loops))) %>% 
    summarize(n.loops=sum(n.loops)) %>%
    ungroup() %>%
    add_column(chr='Genome-Wide') %>% 
    separate_wider_delim(
        SampleID,
        delim='.',
        names=c(NA, 'Celltype', 'Genotype'),
        cols_remove=FALSE
    ) %>%
    # filter(kernel == 'donut') %>% 
    # filter(resolution == '25Kb') %>% 
    filter(sig.lvl %in% c('qval < 0.1', 'N.S.')) %>% 
    make_nested_plot_tabs(
        # group.cols=c('type', 'isMerged', 'weight', 'resolution'),
        group.cols=c('weight', 'resolution'),
        plot.fnc=plot_barplot,
        max.header.lvl=3,
        x.var='SampleID',
        y.var='n.loops',
        fill.var='SampleID', 
        facet.row='sig.lvl',
        facet.col='Celltype',
        legend.position='right',
        scales='free_x',
        # axis.text.x=element_text(angle=45, hjust=1),
        # legend.text=element_text(angle=35, hjust=1),
        axis.title.x=element_blank(),
        axis.title.y=element_blank()
    )
```

## Per Chr

```{r plot_n_loops_heatmap_chr, results='asis', fig.dim=c(10,6)}
n.loops.per.chr.df %>% 
    separate_wider_delim(
        SampleID,
        delim='.',
        names=c(NA, 'Celltype', 'Genotype'),
        cols_remove=FALSE
    ) %>%
    # filter(kernel == 'donut') %>% 
    # filter(resolution == '25Kb') %>% 
    filter(sig.lvl %in% c('qval < 0.1', 'N.S.')) %>% 
    make_nested_plot_tabs(
        # group.cols=c('type', 'isMerged', 'weight', 'resolution'),
        group.cols=c('weight', 'resolution'),
        plot.fnc=plot_barplot,
        max.header.lvl=3,
        x.var='chr',
        x.scale.mode='discrete',
        y.var='n.loops',
        fill.var='SampleID', 
        facet.col='sig.lvl',
        facet.row='Celltype',
        legend.position='right',
        axis.text.x=element_text(angle=45, hjust=1),
        axis.title.x=element_blank(),
        axis.title.y=element_blank()
    )
```

# Size of Loops {.tabset}

Plot size distribution of loops
```{r plot_loop_size_violin, results='asis', fig.dim=c(10,6)}
loops.df %>% 
    # filter(kernel == 'donut') %>% 
    # filter(resolution == '25Kb') %>% filter(weight == 'raw') %>% 
    make_nested_plot_tabs(
        # group.cols=c('type', 'isMerged', 'weight', 'resolution'),
        group.cols=c('weight', 'resolution'),
        max.header.lvl=2,
        plot.fnc=plot_boxplot,
        # quantile.linetype=TRUE,
        x.var='chr',
        # x.scale.mode='discrete',
        y.var='length',
        y.scale.mode='mb',
        fill.var='SampleID', 
        facet.row='kernel',
        legend.position='right',
        outlier.size=0.25,
        axis.text.x=element_text(angle=45, hjust=1),
        # legend.text=element_text(angle=35, hjust=1),
        axis.title.x=element_blank(),
        axis.title.y=element_blank()
    )
```

# Distribution Plots {.tabset}

Make violin plot with q-values
```{r box_plot, results='asis', fig.dim=c(10,6)}
loops.df %>% 
    pivot_longer(
        c('enrichment', 'log10.qval'),
        names_to='metric', 
        values_to='value'
    ) %>% 
    make_nested_plot_tabs(
        # group.cols=c('type', 'isMerged', 'weight', 'resolution'),
        group.cols=c('weight', 'resolution'),
        max.header.lvl=2,
        plot.fnc=plot_boxplot,
        x.var='chr',
        x.scale.mode='discrete',
        y.var='value',
        fill.var='SampleID',
        # plot_pts=TRUE,
        # facet.col='kernel',
        facet.row='metric',
        scales='free_y',
        outlier.size=0.25,
        strip.text.x=element_text(size=5),
        axis.text.x=element_text(angle=45, hjust=1)
    )
```

# Manhattan Plots {.tabset}

Make manhattan plot with q-values
```{r manhattan_plot, results='asis', fig.dim=c(10,6)}
loops.df %>% 
    make_nested_plot_tabs(
        # group.cols=c('type', 'isMerged', 'weight', 'resolution'),
        group.cols=c('weight', 'resolution'),
        max.header.lvl=2,
        plot.fnc=plot_jitter,
        # x.var='SampleID',
        # y.var='log10.qval',
        # color.var='Genotype',
        # shape.var='Genotype',
        x.var='chr',
        y.var='log10.qval',
        color.var='enrichment',
        facet.row='SampleID',
        size=0.25,
        axis.title.x=element_blank(),
        axis.text.x=element_text(angle=45, hjust=1)
    )
```

# Volcano-ish plot Plots {.tabset}

## Genome-Wide {.tabset}

```{r volcanoish_gw, results='asis', fig.dim=c(10,8)}
loops.df %>% 
    # filter(weight == 'raw', resolution == '10Kb') %>% 
    make_nested_plot_tabs(
        # group.cols=c('type', 'isMerged', 'weight', 'resolution'),
        # group.cols=c('weight', 'resolution', 'metric', 'kernel'),
        group.cols=c('weight', 'resolution', 'kernel'),
        max.header.lvl=3,
        plot.fnc=plot_jitter,
        x.var='enrichment',
        y.var='log10.qval',
        color.var='SampleID',
        regression_fnc='lm',
        add_regression_SE=TRUE,
        # facet.group='chr',
        # facet.nrow=4,
        scales='fixed',
        legend.position='right',
        # size=0.25,
        axis.text.x=element_text(angle=45, hjust=1)
    )
```

## Per Chr {.tabset}

```{r volcanoish_chr, results='asis', fig.dim=c(10,6)}
loops.df %>% 
    # filter(weight == 'raw', resolution == '10Kb') %>% 
    make_nested_plot_tabs(
        # group.cols=c('type', 'isMerged', 'weight', 'resolution'),
        # group.cols=c('weight', 'resolution', 'metric', 'kernel'),
        group.cols=c('weight', 'resolution', 'kernel'),
        max.header.lvl=3,
        plot.fnc=plot_jitter,
        x.var='enrichment',
        y.var='log10.qval',
        color.var='SampleID',
        regression_fnc='lm',
        add_regression_SE=TRUE,
        facet.group='chr',
        facet.nrow=4,
        scales='fixed',
        # legend.position='top',
        # size=0.25,
        strip.text=element_text(size=8),
        axis.text.x=element_text(angle=45, hjust=1)
    )
```

# IDR2D Analysis  {.tabset}

## Load IDR2D results

```{r load_idr2d}
# Generate IDR2D results for all comparisons of sample groups
idr2d.results.df <- 
    check_cached_results(
        results_file=LOOPS_IDR2D_RESULTS_FILE,
        # force_redo=TRUE,
        results_fnc=load_all_IDR2D_results
    ) %>% 
    filter(weight == 'balanced', resolution == 10000) %>% 
    # filter(resolve.method == 'overlap') %>% 
    # filter(metric == 'log10.qval') %>% 
    mutate(comparison=glue('{SampleID.P1} vs {SampleID.P2}'))
    mutate(
        is.loop.shared=
            case_when(
                loop.type == 'P1.only' ~ loop.type,
                loop.type == 'P2.only' ~ loop.type,
                IDR < 0.1              ~ 'IDR < 0.1',
                IDR < 1                ~ 'Irreproducible',
                TRUE                   ~ NA
            )
    )
idr2d.results.df  %>% count(is.loop.shared)
```

## Compare resolving strategies + metrics

```{r idr2d_hyperparams_histogram, results='asis', fig.dim=c(10,6)}
idr2d.results.df %>% 
    select(-c(diff.value, diff.rank, loop.type)) %>% 
    make_nested_plot_tabs(
        max.header.lvl=3,
        # group.cols=c('weight', 'resolution', 'kernel'),
        # group.cols=c('resolution', 'comparison'),
        group.cols=c('resolution'),
        # plot.fnc=plot_density,
        plot.fnc=plot_histogram,
        x.var='IDR',
        fill.var='resolve.method',
        facet.col='metric',
        facet.row='chr',
        # y.scale.mode='discrete',
        scales='free',
        legend.position='top',
        strip.text=element_text(size=10),
        axis.title.y=element_blank()
        # group.cols=c('resolution'),
        # plot.fnc=plot_violin,
        # y.var='chr',
        # y.scale.mode='discrete',
        # x.var='IDR',
        # color.var='metric',
        # facet.row='resolve.method',
        # scales='fixed',
        # legend.position='top',
        # strip.text=element_text(size=5),
        # axis.text.x=element_text(angle=45, hjust=1),
        # axis.title.x=element_blank()
    )
```

## Compare resolving strategies + metrics

```{r idr2d_hyperparams_boxplot, results='asis', fig.dim=c(10,6)}
idr2d.results.df %>% 
    select(-c(diff.value, diff.rank, IDR)) %>% 
    count(
        weight, resolution, kernel,
        resolve.method, metric,
        comparison, chr,
        loop.type
    ) %>% 
    # mutate(hyper=glue('{metric} || {resolve.method}')) %>% 
    make_nested_plot_tabs(
        max.header.lvl=3,
        # group.cols=c('weight', 'resolution', 'kernel'),
        # group.cols=c('resolution', 'comparison'),
        group.cols=c('resolution'),
        # plot.fnc=plot_density,
        plot.fnc=plot_barplot,
        y.var='loop.type',
        y.scale.mode='discrete',
        x.var='n',
        fill.var='resolve.method',
        facet.col='metric',
        # fill.var='hyper',
        # facet.col='comparison',
        facet.row='chr',
        # y.scale.mode='discrete',
        # scales='free_y',
        legend.position='top',
        strip.text=element_text(size=10),
        axis.text.x=element_text(angle=45, hjust=1),
        axis.title.x=element_blank()
    )
```

## Quantify reproducible loops across conditions

## Plot expression of genes in loops

# Compare Loops across Genotypes {.tabset}

Pivot anchor data
```{r compare_anchors, eval=FALSE}
similarity.df <- 
    loops.df %>%
    select(-c(count, enrichment, log10.qval)) %>% 
    rename(
        start=anchor.left,
        end=anchor.right
    ) %>% 
    nest(
        boundaries=
            c(
                start,
                end,
                length
            )
    ) %>% 
    mutate(SampleID) %>% 
    check_cached_results(
        results_file=LOOP_SIMILARITY_RESULTS_FILE,
        # force_redo=TRUE,
        results_fnc=calculate_all_boundary_similarities,
        boundaries.df=.,
        sample.group.comparisons=
            SAMPLE_GROUP_COMPARISONS %>%
            rename(
                'SampleID.P1'=Sample.Group.Numerator,
                'SampleID.P2'=Sample.Group.Denominator
            ),
        pair_grouping_cols=
            c(
                'weight',
                'resolution',
                'kernel',
                'chr'
            )
    ) %>% 
    mutate(chr=factor(chr, levels=CHROMOSOMES))
# similarity.df %>% dplyr::count(weight, resolution, SampleID)
# similarity.df
```
```{r compute_anchor_diffs, eval=FALSE}
diff.df <- 
    similarity.df %>% 
    # separate_wider_delim(
    #     SampleID,
    #     delim=' vs ',
    #     names=c('SampleID.P1', 'SampleID.P2'),
    #     cols_remove=FALSE
    # ) %>% 
    inner_join(
        loops.df %>%
        select(-c(Edit, Celltype, Genotype, length)),
        by=
            join_by(
                weight,
                kernel,
                resolution,
                chr,
                SampleID.P1 == SampleID,
                start.P1 == anchor.left,
                end.P1 == anchor.right
            )
    ) %>% 
    inner_join(
        loops.df %>%
        select(-c(Edit, Celltype, Genotype, length)),
        suffix=c('.P1', '.P2'),
        by=
            join_by(
                weight,
                kernel,
                resolution,
                chr,
                SampleID.P2 == SampleID,
                start.P2 == anchor.left,
                end.P2 == anchor.right
            )
    ) %>% 
    select(
        weight,
        resolution,
        chr,
        kernel,
        # SampleID.P1,
        # SampleID.P2
        # Edit,
        # Genotype,
        # Celltype,
        SampleID,
        start.P1,
        start.P2,
        end.P1,
        end.P2,
        length.P1,
        length.P2,
        count.P1,
        count.P2,
        enrichment.P1,
        enrichment.P2,
        log10.qval.P1,
        log10.qval.P2,
        # start.diff,
        # end.diff,
        # length.diff,
        # count.diff,
        # enrichment.diff,
        # log10.qval.diff,
        # jaccard
        # moc.inner,
        # MoC.norm,
    ) %>%
    group_by(weight, resolution, chr, kernel, SampleID) %>% 
    mutate(pair.idx=row_number()) %>% 
    ungroup() %>% 
    rename_with(~str_replace(.x, 'log10.qval', 'log10_qval')) %>% 
    pivot_longer(
        c(ends_with('.P1'), ends_with('.P2')),
        names_to='metric',
        values_to='value',
    ) %>%
    separate_wider_delim(
        metric,
        delim='.',
        names=c('metric', 'pair.side')
    ) %>% 
    pivot_wider(
        names_from=pair.side,
        values_from=value
    ) %>% 
    mutate(diff=P2 - P1)
```

## Plot anchor differences boxplot {.tabset}

```{r plot_compare_anchors_boxplot, results='asis', fig.dim=c(10,6), eval=FALSE}
diff.df %>% 
    # filter(!metric %in% c('start', 'end', 'length')) %>% 
    filter(metric %in% c('length', 'enrichment', 'log10_qval')) %>% 
    mutate(diff=abs(diff)) %>% 
    make_nested_plot_tabs(
        # group.cols=c('type', 'isMerged', 'weight', 'resolution'),
        group.cols=c('weight', 'resolution'),
        max.header.lvl=3,
        plot.fnc=plot_boxplot,
        x.var='chr',
        y.var='diff',
        fill.var='SampleID',
        facet.row='metric',
        x.scale.mode='discrete',
        scales='free_y',
        legend.position='top',
        axis.title.x=element_blank(),
        strip.text=element_text(size=20),
        axis.text.x=element_text(angle=45, hjust=1)
    )
```

## Plot anchor differences scatter {.tabset}

```{r plot_compare_anchors_scatter, results='asis', fig.dim=c(10,6), eval=FALSE}
diff.df %>% 
    # filter(metric %in% c(start, end, length)) %>% 
    # filter(!metric %in% c('start', 'end', 'length')) %>% 
    filter(metric %in% c('enrichment', 'log10_qval')) %>% 
    make_nested_plot_tabs(
        # group.cols=c('type', 'isMerged', 'weight', 'resolution'),
        group.cols=c('weight', 'resolution'),
        max.header.lvl=3,
        plot.fnc=plot_jitter,
        x.var='P1',
        y.var='P2',
        color.var='SampleID',
        # facet.row='metric',
        facet.group='metric',
        facet.ncol=1,
        scales='free',
        size=0.75,
        legend.position='top',
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        strip.text=element_text(size=20),
        axis.text.x=element_text(angle=45, hjust=1)
    )
```

## Plot Anchor MoCs {.tabset}

```{r plot_compare_anchors_MoC, results='asis', fig.dim=c(10,6), eval=FALSE}
similarity.df %>% 
    # select(-c(ends_with('diff'))) %>% 
    group_by(weight, resolution, chr, kernel, SampleID) %>%
    summarize(MoC=(sum(moc.inner) - 1) * unique(MoC.norm)) %>% 
    ungroup() %>% 
    make_nested_plot_tabs(
        # group.cols=c('type', 'isMerged', 'weight', 'resolution'),
        group.cols=c('weight', 'resolution'),
        max.header.lvl=3,
        plot.fnc=plot_barplot,
        x.var='chr',
        y.var='MoC',
        # color.var='Genotype',
        # shape.var='Genotype',
        # x.var='Genotype',
        fill.var='SampleID',
        # facet.col='chr',
        # facet.row='context',
        x.scale.mode='discrete',
        # y.scale.mode='mb',
        # scales='free_y',
        # size=0.25,
        legend.position='top',
        axis.title.x=element_blank(),
        axis.text.x=element_text(angle=45, hjust=1)
    )
```

# Plot against genome annotations

## Plot loops against CTCF sites

## Plot against CNVs?

