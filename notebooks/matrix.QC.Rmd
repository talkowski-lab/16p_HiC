---
title: "QC stats for 16p HiC samples"
author: "Siddharth Reed"
date: "`r Sys.Date()`"
---

<style type="text/css">
.main-container {
  max-width: 1800px !important;
  margin-left: auto;
  margin-right: auto;
}
</style>

# Dependencies

```{r knitr}
library(knitr)
knitr::opts_chunk$set(
    results=FALSE,
    message=FALSE,
    warning=FALSE,
    dev=c('png', 'pdf', 'svg'),
    dpi=300
)
```
Set up file locations + load dependenies
```{r dependencies}
library(here)
here::i_am('notebooks/matrix.QC.Rmd')
BASE_DIR <- here()
source(file.path(BASE_DIR, 'scripts/locations.R'))
source(file.path(SCRIPT_DIR, 'constants.R'))
source(file.path(SCRIPT_DIR, 'utils.data.R'))
source(file.path(SCRIPT_DIR, 'utils.plot.R'))
source(file.path(SCRIPT_DIR, 'utils.qc.R'))
library(tidyverse)
library(magrittr)
library(ggplot2)
library(ggh4x)
library(purrr)
library(kableExtra)
```
Load sample metadata
```{r load_metadata}
sample.metadata.df <- 
    load_sample_metadata()
```

# Bin-wise coverage of contacts {.tabset}

## Minimum Viable Resolution

The minimum usable resolution for a HiC dataset is defined in [Rao et al. 2014](https://www.cell.com/cell/fulltext/S0092-8674(14)01497-4?cc=y%3D) as follows

>We define the “matrix resolution” of a Hi-C map as the locus size used to construct a particular contact matrix and the “map resolution” as the smallest locus size such that 80% of loci have at least 1,000 contacts.

```{r coallate_marginal_contacts_rachita, eval=F}
coverage.summary <- 
    check_cached_results(
        results_file=RACHITA_COVERAGE_RESULTS_FILE,
        # force_redo=TRUE,
        resolutions=c(100, 50, 25, 10, 5) * 1e3,  # Kbs
        sample.metadata.df=sample.metadata.df,
        results_fnc=
           function(resolutions, sample.metadata.df, ...){
                load_all_coverage_data(resolutions=resolutions) %>% 
                # standardize_data_cols() %>% 
                left_join(
                    sample.metadata.df %>%
                    select(SampleID, FlowcellID),
                    by=join_by(SampleID)
                ) %>%
                mutate(FlowcellID=ifelse(is.na(FlowcellID), 'Merged', FlowcellID))
           }
    )
```

```{r calc_resolution}
coverage.summary <- 
    check_cached_results(
        results_file=RESOLTION_COVERAGE_SUMAMRY_FILE,
        # force_redo=TRUE,
        results_fnc=compute_all_coverage_summaries,
        resolutions=c(100, 50, 25, 10, 5) * 1e3   # Kbs
    ) %>%
    standardize_data_cols() %>% 
    left_join(
        sample.metadata.df %>%
        select(SampleID, FlowcellID),
        by=join_by(SampleID)
    ) %>%
    mutate(FlowcellID=ifelse(is.na(FlowcellID), 'Merged', FlowcellID))
```
Now print all resolutions which are usable according to the Rao et al. 2014 definition
```{r print_valid_resolutions, results=TRUE, paged.print=TRUE, max.print=10000}
min.resolutions <- 
    coverage.summary %>% 
    pivot_wider(
        names_from='metric',
        values_from='value'
    ) %>% 
    # Pick relevant coverage results
    filter(
        ReadFilter == 'mapq_30',
        count.type == 'cis',
        chr == 'Genome.Wide',
        bins.pct.covered >= 0.80
    ) %>% 
    # Pick smallest resolution with sufficient coverage
    group_by(SampleID) %>% 
    slice_min(resolution, n=1) %>% 
    ungroup() %>% 
    # format results for human readability
    mutate(bins.pct.covered=sprintf("%0.1f%%", bins.pct.covered * 100)) %>% 
    arrange(SampleID) %T>%
    write_tsv(MIN_SAMPLE_RESOLUTION_FILE) %>% 
    # mutate(resolution=scale_numbers(resolution)) %>% 
    rename(
        'Min. Viable Resolution'=resolution, 
        '# Total Bins'=bins.n.total,
        '# Bins > 0'=bins.n.nz,
        '% Bins > 0'=bins.pct.nz,
        '# Bins >= 1K'=bins.n.covered,
        '% Bins >= 1K'=bins.pct.covered,
    )
min.resolutions %>% 
    arrange(SampleID) %>%
    select(
        SampleID,
        `Min. Viable Resolution`,
        `% Bins >= 1K`,
        `# Bins >= 1K`,
        `# Total Bins`
    ) #%>% 
    # kbl() %>% 
    # kable_styling(bootstrap_options=c("striped", "hover"))
```

## Summary Stats {.tabset}

```{r total_heatmaps, results='asis', fig.dim=c(8,5)}
coverage.summary %>% 
    filter(
        weight == 'raw',
        isGenome == 'Per.Chr',
        count.type == 'cis'
    ) %>% 
    filter(metric %in% 
        c(
            'coverage.median',
            'coverage.mean',
            # 'coverage.max',
            'coverage.total',
            'bins.pct.nz',
            'bins.pct.covered'
        )
    ) %>% 
    mutate(
        labels=
            case_when(
                grepl('.pct.', metric) ~ scales::number(value, accuracy=0.01, stype_positive='none'),
                TRUE                   ~ scales::number(value, accuracy=0.1,  stype_positive='none', scale_cut=cut_short_scale())
            )
    ) %>% 
    make_nested_plot_tabs(
        plot.fnc=plot_heatmap,
        # group.cols=c('isGenome', 'isMerged', 'metric', 'resolution'),
        group.cols=c('isMerged', 'metric', 'resolution'),
        max.header.lvl=3,
        x.var='chr',
        y.var='SampleID',
        fill.var='value', 
        facet.row='Celltype',
        scales='free',
        label.var='labels',
        label.size=1.75,
        label.color='white',
        legend.position='top',
        legend.text=element_text(angle=45, hjust=1),
        axis.text.x=element_text(angle=45, hjust=1),
        element.title=element_blank(),
        plot.elements=
            list(
                scale_fill_continuous(
                    labels=scales::label_number(scale_cut=scales::cut_short_scale())
                )
            )
                    
    )
```

# Plot pairs by distance {.tabset}

```{r pair_plot_df, include=FALSE}
sample.metadata.df <- 
    load_sample_metadata(filter=FALSE)
pair.stats.list <- 
    load_pairtools_stats()
pairs.plot.df <- 
    pair.stats.list %>%
    make_pair_qc_df() %>% 
    get_info_from_SampleIDs() %>%
    left_join(
        sample.metadata.df %>%
        select(SampleID, FlowcellID, Included),
        by=join_by(SampleID)
    ) %>%
    # filter(Included | isMerged == 'Merged') %>% select(-c(Included)) %>% 
    # filter(isMerged == 'Merged') %>% select(-c(Included)) %>% 
    mutate(FlowcellID=ifelse(is.na(FlowcellID), 'Merged', FlowcellID))
barplot.ggtheme <- 
    make_ggtheme(
        legend.position='right',
        legend.text=element_text(size=5),
        legend.key.size=unit(10, "pt"),
        axis.text.x=element_text(size=4.5, angle=35, hjust=1),
        axis.title.x=element_blank()
    )
```

## Number of pairs 

```{r plot_n_pairs, fig.dim=c(7,5)}
pairs.plot.df %>% 
    filter(Included | isMerged == 'Merged') %>% 
    rename('Unique Pairs'=value) %>% 
    plot_barplot(
        x.var='Category',
        y.var='Unique Pairs',
        fill.var='SampleID',
        facet.col='Celltype',
        facet.row='isMerged',
        x.scale.mode='discrete',
        y.scale.mode='log10',
        legend.cols=2,
        scales='free_y',
        y.limits=c(1e6, NA),
        theme.obj=barplot.ggtheme
    )
```

## % of pairs 

```{r plot_pct_pairs, fig.dim=c(7,5)}
pairs.plot.df %>% 
    filter(Included | isMerged == 'Merged') %>% 
    rename('Unique Pairs'=frac) %>% 
    plot_barplot_with_threshold_lines(
        # normal barplot arguments
        x.var='Category',
        y.var='Unique Pairs',
        fill.var='SampleID',
        facet.col='Celltype',
        facet.row='isMerged',
        x.scale.mode='discrete',
        y.scale.mode='pct',
        theme.obj=barplot.ggtheme,
        legend.cols=2,
        # where to draw lines
        scales='free_y',
        lines.df=
            tribble(
                ~Category, ~y_lower, ~y_upper,
                'Long Range  >  20Kb', 0.15, 0.40
            )
    )
```

## % of pairs  (by batch) {.tabset}

```{r plot_pct_pairs_batch, results='asis', fig.dim=c(10, 6)}
pairs.plot.df %>% 
    rename('Unique Pairs'=frac) %>% 
    # filter(FlowcellID == 'Merged', isMerged == 'Individual') %>% 
    # dplyr::count(FlowcellID, isMerged)
    make_nested_plot_tabs(
        plot.fnc=plot_barplot_with_threshold_lines,
        group.cols=c('isMerged'),
        max.header.lvl=3,
        # normal barplot arguments
        x.var='Category',
        y.var='Unique Pairs',
        fill.var='SampleID',
        facet.col='FlowcellID',
        facet.row='Celltype',
        x.scale.mode='discrete',
        y.scale.mode='pct',
        theme.obj=barplot.ggtheme,
        legend.cols=1,
        # where to draw lines
        scales='free_y',
        lines.df=
            tribble(
                ~Category, ~y_lower, ~y_upper,
                'Long Range  >  20Kb', 0.15, 0.40
            )
    )
```

# Plot heatmap of cis/trans interactions {.tabset}

```{r noncon_chr_mapping, include=FALSE}
# Count how many pairs of map to non-canonical chromosomes in the assembly
message('Print reads mapping to unused chromosomes')
pair.stats.list$chr.stats %>% 
    mutate(
        pair.types=
            case_when( 
                grepl('(_|EBV)', chr1) | grepl('(_|EBV)', chr2) ~ 'artifact',
                chr1 == chr2 ~ 'cis',
                chr1 != chr2 ~ 'trans'
            )
    ) %>%
    group_by(SampleID, pair.types) %>% 
    dplyr::summarize(sum=sum(value))
```
Get number of contacts between all pairs of chromosomes (intra & inter)
```{r cis_trans_plot_df, include=FALSE}
plot.df  <- 
    pair.stats.list$chr.stats %>% 
    rename('contacts'=value) %>% 
    mutate(
        across(
            starts_with('chr'),
            ~ factor(.x, levels=CHROMOSOMES)
        )
    ) %>% 
    group_by(SampleID) %>% 
    mutate(
        `Total Contacts`=contacts,
        `% Total Contacts`=100 * (contacts / total.unique.contacts),
        `log10(Contacts)`=log10(contacts)
    ) %>%
    ungroup() %>% 
    pivot_longer(
        c(`% Total Contacts`, `log10(Contacts)`, `Total Contacts`),
        names_to='metric',
        values_to='value'
    ) %>% 
    get_info_from_SampleIDs(
        sample_ID_col='SampleID',
        keep_id=TRUE,
        nest_col=NA
    )
```
Plot all contacts between all chromosomes as heatmaps
```{r plot_cis_trans, results='asis', fig.dim=c(10,10)}
plot.df %>% 
    make_nested_plot_tabs(
        plot.fnc=plot_heatmap,
        group.cols=c('isMerged', 'Genotype', 'metric'),
        max.header.lvl=2,
        x.var='chr1',
        y.var='chr2',
        fill.var='value',
        facet.group='SampleID',
        scales='fixed',
        axis.text.x=element_text(angle=45, hjust=1),
        legend.position='top',
        legend.text=element_text(angle=45, hjust=1),
        plot.elements=
            list(
                scale_fill_continuous(
                    labels=scales::label_number(scale_cut=scales::cut_short_scale())
                ),
                scale_fill_gradient(
                    low='grey90',
                    high='red'
                ),
                theme(axis.title=element_blank())
            )
    )
                    
```

# Plot read orientation frequency over distance {.tabset}

Recreating Figure 1 from the [ENCODE HiC Guidelines](https://www.encodeproject.org/documents/75926e4b-77aa-4959-8ca7-87efcba39d79/).
First format all the orientation data
```{r pair_orientation_df}
pair.orientation.df <- 
    pair.stats.list$distance.stats %>% 
    mutate(
        range.end=
            ifelse(
                is.na(range.end), 
                range.start+1,
                range.end
            )
    ) %>% 
    mutate(
        orientation=
            orientation %>%
            str_replace_all(fixed('+'), '>') %>% 
            str_replace_all(fixed('-'), '<')
    ) %>% 
    get_info_from_SampleIDs()
```
Now plot distance vs # of pairs for each pair orientation
```{r plot_pair_orientation, results='asis', fig.dim=c(11,10)}
pair.orientation.df %>% 
    filter(interaction == 'cis') %>% select(-c(interaction)) %>%
    filter(value > 0) %>% 
    make_nested_plot_tabs(
        plot.fnc=plot_pair.orientation_lineplot,
        group.cols=c('isMerged', 'Genotype'),
        facet.group='SampleID',
        facet.ncol=3,
        x.scale.mode='log10',
        y.scale.mode='log10',
        # legend.position='inside',
        # legend.position.inside=c(0.85, 0.20),
        scales='fixed'
    )
```

# Download Sample Stats

`.tsv` of stats per sample 
```{r download_stats}
library(downloadthis)
make_summary_stats_table(
    min.resolutions,
    pair.stats.list,
    pairs.plot.df %>%
        select(-c(Edit, Celltype, Genotype, CloneID, TechRepID)),
) %>% 
download_this(
    output_name="16p_HiC_Matrix_QCStats",
    button_type="default",
    output_extension=".csv",
    csv2=TRUE
)
```
