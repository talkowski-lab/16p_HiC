---
title: "QC stats for 16p HiC samples"
author: "Siddharth Reed"
date: "`r Sys.Date()`"
output: 
    html_document:
        toc: true
        toc_float: true
        theme: paper
        code_folding: hide
        df_print: paged
---

<style type="text/css">
.main-container {
  max-width: 1800px !important;
  margin-left: auto;
  margin-right: auto;
}
</style>

# Prepare data

```{r knitr}
library(knitr)
knitr::opts_chunk$set(
    dev=c('png', 'pdf', 'tiff'),
    dpi=300
)
```
Set up file locations
```{r load_paths, echo=FALSE, message=FALSE, results=FALSE}
library(here)
BASE_DIR=here()
source(file.path(BASE_DIR, 'scripts/locations.R'))
```
Load dependencies
```{r load_deps, results=FALSE, message=FALSE, echo=FALSE}
library(tidyverse)
library(magrittr)
library(downloadthis)
source(file.path(BASE_DIR, 'scripts/utils.data.R'))
source(file.path(BASE_DIR, 'scripts/utils.qc.R'))
source(file.path(BASE_DIR, 'scripts/utils.plot.R'))
sample.metadata <- load_sample_metadata()
```
Load output of `pairtools stats` 
```{r load_stats, rows.print=5, message=FALSE, results=FALSE}
pair.stats.list <- load_pairtools_stats()
# pair.stats.list$general.stats
# pair.stats.list$distance.stats
# pair.stats.list$chr.stats
```
Load genome coverage from `cooltools coverage`
```{r load_coverage, rows.print=5}
genome.coverage <- 
    check_cached_results( 
        results_file=NULL,
        force_redo=FALSE,
        return_data=TRUE,
        results_fnc=load_genome_coverage,
        weights=c('raw'),
        resolutions=c(5000, 10000, 25000)
    ) %>% 
    mutate(resolution=as.integer(resolution)) %>% 
    select(-c(filepath))
genome.coverage
```

# Calculate minimum resolution from pair orientations

The minimum usable resolution for a HiC dataset is defined in [Rao et al. 2014](https://www.cell.com/cell/fulltext/S0092-8674(14)01497-4?cc=y%3D) as follows

>We define the “matrix resolution” of a Hi-C map as the locus size used to construct a particular contact matrix and the “map resolution” as the smallest locus size such that 80% of loci have at least 1,000 contacts.

```{r calc_resolution, include=FALSE}
# Variables to count coverage across
grouping_cols <- 
    genome.coverage %>%
    colnames() %>%
    {.[!grepl("(start|end|coverage)", .)]}
# print(grouping_cols)
coverage.summary <- 
    genome.coverage %>%
    group_by(across(grouping_cols)) %>%
    summarize(
        bins.n.nz=sum(coverage > 0),
        bins.n.covered=sum(coverage > 1000),
        bins.n.total=n()
    ) %>%
    ungroup() %>%
    # Calculate totals by summing per chr values
    bind_rows(
        .,
        {.} %>%
        group_by(across(grouping_cols[!grepl("chr", grouping_cols)])) %>% 
        summarize(
            across(
                starts_with('bins.n.'),
                ~ sum(.x)
            )
        ) %>%
        add_column(chr='genome.wide')
    ) %>%
    mutate(
        bins.pct.nz=bins.n.nz / bins.n.total,
        bins.pct.covered=bins.n.covered / bins.n.total
    )
```
Now print all resolutions which are usable according to the Rao et al. 2014 definition
```{r print_valid_resolutions, paged.print=TRUE, max.print=10000}
coverage.summary %>% 
    filter(chr == 'genome.wide') %>%
    filter(weight == 'raw') %>% 
    filter(ReadFilter == 'mapq_30') %>% 
    filter(metric == 'cis') %>% 
    filter(bins.pct.covered >= 0.80) %>% 
    group_by(Sample.ID) %>% 
    slice_min(resolution, n=1) %>% 
    left_join(RESOLUTION_NAMES, by='resolution') %>% 
    mutate(bins.pct.covered=sprintf("%0.1f%%", bins.pct.covered * 100)) %>% 
    select(
        Sample.ID,
        resolution.name,
        bins.pct.covered,
        bins.n.covered,
        bins.n.total
    ) %>%
    arrange(Sample.ID, resolution.name) %>% 
    rename(
        'Usable Resolution'=resolution.name, 
        '% Bins >= 1K'=bins.pct.covered,
        '# Bins >= 1K'=bins.n.covered,
        '# Total Bins'=bins.n.total,
    ) %>%
    kable(align=c('l', 'r', 'r', 'r', 'r'))
```

# Plot read orientation frequency over distance

Recreating Figure 1 from the [ENCODE HiC Guidelines](https://www.encodeproject.org/documents/75926e4b-77aa-4959-8ca7-87efcba39d79/).

```{r plot_pair_orientation, results='asis', message=FALSE, warning=FALSE}
pair.stats.list$distance.stats %>% 
    filter(interaction == 'cis') %>% select(-c(interaction)) %>%
    filter(value > 0) %>% 
    mutate(
        range.end=
            ifelse(
                is.na(range.end), 
                range.start+1,
                range.end
            )
    ) %>% 
    mutate(
        orientation=
            orientation %>%
            str_replace_all(fixed('+'), '>') %>% 
            str_replace_all(fixed('-'), '<')
    ) %>% 
    separate_wider_delim(
        Sample.ID,
        delim=fixed('.'),
        names=c('Edit', 'Genotype', 'SampleNumber', 'Celltype'),
        cols_remove=FALSE
    ) %>% 
    make_nested_plot_tabs(
        group_cols=c('Celltype', 'Genotype', 'Sample.ID'),
        plot_fnc=plot_pair.orientation_lineplot
    )
```

# Plot pairs by distance

```{r pair_plot_df, include=FALSE}
pair.plot.df <- 
    pair.stats.list$general.stats %>% 
    select(-c(category)) %>% 
    filter(stat %in% c('trans', 'cis')) %>% 
    dplyr::rename('interaction'=stat) %>% 
    add_column(range.start=0) %>% 
    bind_rows(pair.stats.list$distance.stats) %>% 
    mutate(
        range.end=ifelse(is.na(range.end), Inf, range.end),
        Category=
            case_when(
                orientation =='-+'   & range.end < 1001    ~ 'self-circle', 
                orientation =='+-'   & range.end < 1001    ~ 'dangling-end', 
                range.start >= 20000                       ~ 'Long.Range  >  20Kb',
                range.start >=  1000 & range.start < 20001 ~ 'Short.Range <= 20Kb',
                range.end   <=  1000                       ~ 'Too.Short   <=  1Kb',
                interaction == 'cis' & range.end == Inf    ~ 'Cis.Total',
                interaction == 'trans'                     ~ 'Trans',
            )
    ) %>%
    mutate(
        Category=
            factor(
                Category,
                levels=
                    c(
                        'self-circle', 
                        'dangling-end', 
                        'Too.Short   <=  1Kb',
                        'Short.Range <= 20Kb',
                        'Long.Range  >  20Kb',
                        'Cis.Total',
                        'Trans'
                    )
            )
    ) %>% 
    group_by(Sample.ID, Category) %>% 
    summarize(
        value=sum(value),
        # total per sample
        total.unique.contacts=unique(total.unique.contacts)
    ) %>% 
    ungroup() %>% 
    mutate(frac=100 * (value / total.unique.contacts))
```

```{r plot_pairs, echo=FALSE, fig.align='center', fig.height=5}
pair.plot.df %>% 
    separate_wider_delim(
        Sample.ID,
        delim=fixed('.'),
        names=c('Edit', 'Genotype', 'SampleNumber', 'Celltype'),
        cols_remove=FALSE
    ) %>% 
    mutate(is.Merged=ifelse(grepl('Merged', Sample.ID), 'Merged', 'Individual')) %>% 
    rename('% Unique Contacts'=frac) %>% 
    plot_qc_barplot(
        y_val='% Unique Contacts',
        facet_col='Celltype',
        facet_row='is.Merged'
    )
```

# Plot heatmap of cis/trans interactions

```{r noncon_chr_mapping, include=FALSE}
message('Print reads mapping to unused chromosomes')
pair.stats.list$chr.stats %>% 
    mutate(
        pair.types=
            case_when( 
                grepl('(_|EBV)', chr1) | grepl('(_|EBV)', chr2) ~ 'artifact',
                chr1 == chr2 ~ 'cis',
                chr1 != chr2 ~ 'trans'
            )
    ) %>%
    group_by(Sample.ID, pair.types) %>% 
    dplyr::summarize(sum=sum(value))
```

```{r cis_trans_plot_df, include=FALSE}
plot.df  <- 
    pair.stats.list$chr.stats %>% 
    rename('contacts'=value) %>% 
    filter( 
        if_all(
            starts_with('chr'),
            ~ !grepl('(_|EBV)', .x)
        )
    ) %>% 
    mutate(
        across(
            starts_with('chr'),
            ~ factor(.x, levels=CHROMOSOMES)
        )
    ) %>% 
    group_by(Sample.ID) %>% 
    mutate(
        `% Total Contacts`=100 * (contacts / total.unique.contacts),
        `log10(Contacts)`=log10(contacts)
    ) %>%
    ungroup() %>% 
    pivot_longer(
        c(`% Total Contacts`, `log10(Contacts)`),
        names_to='metric',
        values_to='value'
    )
```

```{r plot_cis_trans, results='asis'}
tmp_plot <- function(plot.df){
    col_name <- plot.df$metric %>% unique() %>% first()
    plot.df %>%
    pivot_wider(
        names_from=metric,
        values_from=value
    ) %>% 
    plot_cistrans_chromosome_heatmap(fill_var=col_name)
}
plot.df %>% 
    filter(metric == "% Total Contacts") %>% 
    separate_wider_delim(
        Sample.ID,
        delim=fixed('.'),
        names=c('Edit', 'Genotype', 'SampleNumber', 'Celltype'),
        cols_remove=FALSE
    ) %>% 
    make_nested_plot_tabs(
        group_cols=c('Celltype', 'Genotype', 'Sample.ID'),
        plot_fnc=tmp_plot
    )
```

# Download Sample Stats

`.tsv` of stats per sample 

```{r download_stats}
# Start with coverage data
coverage.summary %>%
    filter(
        weight == 'raw',
        metric == 'cis',
        chr == 'genome.wide',
        ReadFilter == 'mapq_30',
        bins.pct.covered >= 0.80
    ) %>% 
    group_by(Sample.ID) %>% 
    slice_min(resolution, n=1) %>% 
    ungroup() %>% 
    select(
        -c(
            weight,
            metric,
            chr
        )
    ) %>%
    mutate(ReadFilter=as.integer(str_remove(ReadFilter, 'mapq_'))) %>% 
    pivot_longer(
        c(starts_with('bins'), resolution, ReadFilter),
        names_to='metric',
        values_to='n'
    ) %>%
    mutate(
        metric=
            case_when(
                metric == 'bins.n.nz'        ~ NA,
                metric == 'bins.n.covered'   ~ 'Bins >= 1K Contacts',
                metric == 'bins.n.total'     ~ NA,
                metric == 'bins.pct.nz'      ~ NA,
                metric == 'bins.pct.covered' ~ '% Bins >= 1K Contacts',
                metric == 'resolution'       ~ 'Minimum Viable Resolution',
                metric == 'min_mapq'         ~ 'Minimum MAPQ',
                TRUE ~ NA
            )
    ) %>% 
    filter(!is.na(metric)) %>% 
    # Add stats per matrix
    bind_rows(
        pair.stats.list$general.stats %>%
        select(
            Sample.ID,
            stat,
            value
        ) %>%
        rename(
            'metric'=stat,
            'n'=value
        )
    ) %>% 
    # add pair categories
    bind_rows(
        pair.plot.df %>%
        select(
            Sample.ID,
            Category,
            value
        ) %>%
        rename(
            'metric'=Category,
            'n'=value
        ) %>%
        mutate(metric=paste0('pairs.', metric))
    ) %>% 
    pivot_wider(
        names_from=metric,
        values_from=n
    ) %>% 
    download_this(
        output_name="16p_HiC_Matrix_QCStats",
        button_type="default",
        output_extension=".csv",
        csv2=TRUE
    )
```
