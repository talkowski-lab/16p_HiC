---
title: "QC stats for 16p HiC samples"
author: "Siddharth Reed"
date: "`r Sys.Date()`"
output: 
    html_document:
        keep_md: true
        toc: true
        toc_float: true
        theme: paper
        code_folding: hide
        df_print: paged
---

<style type="text/css">
.main-container {
  max-width: 1800px !important;
  margin-left: auto;
  margin-right: auto;
}
</style>

# Prepare data

```{r knitr}
library(knitr)
knitr::opts_chunk$set(
    dev=c('png', 'pdf', 'svg'),
    dpi=300
)
```
Set up file locations + load dependenies
```{r file_locs, results=FALSE, message=FALSE, warning=FALSE}
library(here)
here::i_am('notebooks/matrix.QC.Rmd')
BASE_DIR <- here()
SCRIPT_DIR <- here('scripts')
source(file.path(SCRIPT_DIR, 'locations.R'))
source(file.path(SCRIPT_DIR, 'constants.R'))
source(file.path(SCRIPT_DIR, 'utils.data.R'))
source(file.path(SCRIPT_DIR, 'utils.plot.R'))
source(file.path(SCRIPT_DIR, 'utils.qc.R'))
library(tidyverse)
library(magrittr)
library(ggplot2)
library(ggh4x)
library(purrr)
library(downloadthis)
sample.metadata <- load_sample_metadata(filter=FALSE)
samples.to.include <- sample.metadata %>% filter(Included) %>% pull(SampleID)
```

# Calculate minimum resolution from pair orientations

The minimum usable resolution for a HiC dataset is defined in [Rao et al. 2014](https://www.cell.com/cell/fulltext/S0092-8674(14)01497-4?cc=y%3D) as follows

>We define the “matrix resolution” of a Hi-C map as the locus size used to construct a particular contact matrix and the “map resolution” as the smallest locus size such that 80% of loci have at least 1,000 contacts.

Requires that coverage data (i.e. bin-wise sum of all contacts) that is generated by `cooltools coverage`

```{r calc_resolution, include=FALSE}
coverage.summary <- 
    check_cached_results(
        results_file=RESOLTION_COVERAGE_SUMAMRY_FILE,
        # force_redo=TRUE,
        force_redo=FALSE,
        return_data=TRUE,
        show_col_types=FALSE,
        results_fnc=get_all_matrix_minimum_resolutions,
        resolutions=c(100, 50, 25, 10, 5, 2) * 1e3   # Kbs
    )
```
Now print all resolutions which are usable according to the Rao et al. 2014 definition
```{r print_valid_resolutions, paged.print=TRUE, max.print=10000}
min.resolutions <- 
    coverage.summary %>% 
    filter(SampleID %in% samples.to.include | str_detect(SampleID, 'Merged')) %>% 
    # Pick relevant coverage results
    filter(
        str_detect(SampleID, 'Merged') | 
            (ReadFilter == 'mapq_30' & metric == 'cis' & chr == 'genome.wide'),
        bins.pct.covered >= 0.80
    ) %>% 
    # Pick smallest resolution with sufficient coverage
    group_by(SampleID) %>% 
    slice_min(
        resolution, 
        n=1
    ) %>% 
    ungroup() %>% 
    # format results for human readability
    mutate(bins.pct.covered=sprintf("%0.1f%%", bins.pct.covered * 100)) %>% 
    arrange(SampleID) %T>%
    write_tsv(MIN_SAMPLE_RESOLUTION_FILE) %>% 
    mutate(resolution=scale_numbers(resolution)) %>% 
    rename(
        'Min. Viable Resolution'=resolution, 
        '# Total Bins'=bins.n.total,
        '# Bins > 0'=bins.n.nz,
        '% Bins > 0'=bins.pct.nz,
        '# Bins >= 1K'=bins.n.covered,
        '% Bins >= 1K'=bins.pct.covered,
    )
min.resolutions %>% 
    arrange(SampleID) %>%
    select(
        SampleID,
        `Min. Viable Resolution`,
        `# Total Bins`,
        `% Bins >= 1K`,
        `# Bins >= 1K`
    )
```

# Plot pairs by distance {.tabset}

Load output of `pairtools stats` 
```{r load_stats, rows.print=5, message=FALSE, results=FALSE}
pair.stats.list <- 
    load_pairtools_stats()
    # load_pairtools_stats(samples.to.include=samples.to.include)
pairs.plot.df <- 
    pair.stats.list %>%
    make_pair_qc_df() %>% 
    get_info_from_SampleIDs()
barplot.ggtheme <- 
    make_ggtheme(
        legend.position='right',
        legend.text=element_text(size=7),
        legend.key.size=unit(10, "pt"),
        axis.text.x=element_text(angle=35, hjust=1),
        axis.title.x=element_blank()
    )
```

## Number of pairs 

```{r plot_n_pairs, echo=FALSE, fig.align='center'}
pairs.plot.df %>% 
    rename('Unique Pairs'=value) %>% 
    filter(SampleID %in% samples.to.include | str_detect(SampleID, 'Merged')) %>% 
    plot_barplot(
        x_var='Category',
        y_var='Unique Pairs',
        fill_var='SampleID',
        facet_col='Celltype',
        facet_row='isMerged',
        scales='free_y',
        scale_mode='log10',
        limits=c(1e6, NA),
        legend_cols=1,
        theme_obj=barplot.ggtheme
    )
```

## % of pairs 

```{r plot_pct_pairs, echo=FALSE, fig.align='center'}
pairs.plot.df %>% 
    rename('Unique Pairs'=frac) %>% 
    filter(SampleID %in% samples.to.include | str_detect(SampleID, 'Merged')) %>% 
    plot_barplot_with_threshold_lines(
        # normal barplot arguments
        x_var='Category',
        y_var='Unique Pairs',
        fill_var='SampleID',
        facet_col='Celltype',
        facet_row='isMerged',
        scales='free_y',
        scale_mode='pct',
        theme_obj=barplot.ggtheme,
        legend_cols=1,
        # where to draw lines
        lines.df=
            tribble(
                ~Category, ~y_lower, ~y_upper,
                'Long Range  >  20Kb', 0.15, 0.40
            )
    )
```

## Compare batches

```{r compare_batches, echo=FALSE, fig.align='center'}
pairs.plot.df %>% 
    rename('Unique Pairs'=frac) %>% 
    filter(!grepl('Merged', SampleID)) %>% 
    plot_barplot_with_threshold_lines(
        # normal barplot arguments
        x_var='Category',
        y_var='Unique Pairs',
        fill_var='SampleID',
        facet_col='TechRepID',
        facet_row='Celltype',
        scales='free_y',
        scale_mode='pct',
        theme_obj=barplot.ggtheme,
        legend_cols=1,
        # where to draw lines
        lines.df=
            tribble(
                ~Category, ~y_lower, ~y_upper,
                'Long Range  >  20Kb', 0.15, 0.40
            )
    )
```

# Plot read orientation frequency over distance

Recreating Figure 1 from the [ENCODE HiC Guidelines](https://www.encodeproject.org/documents/75926e4b-77aa-4959-8ca7-87efcba39d79/).
First format all the orientation data
```{r pair_orientation_df, message=FALSE, warning=FALSE}
pair.orientation.df <- 
    pair.stats.list$distance.stats %>% 
    mutate(
        range.end=
            ifelse(
                is.na(range.end), 
                range.start+1,
                range.end
            )
    ) %>% 
    mutate(
        orientation=
            orientation %>%
            str_replace_all(fixed('+'), '>') %>% 
            str_replace_all(fixed('-'), '<')
    ) %>% 
    get_info_from_SampleIDs()
```
Now plot distance vs # of pairs for each pair orientation
```{r plot_pair_orientation, results='asis', fig.height=6, fig.width=12}
pair.orientation.df %>% 
    filter(interaction == 'cis') %>% select(-c(interaction)) %>%
    filter(value > 0) %>% 
    filter(SampleID %in% samples.to.include | str_detect(SampleID, 'Merged')) %>% 
    make_nested_plot_tabs(
        group_cols=c('Celltype', 'Genotype'),
        plot_fnc=plot_pair.orientation_lineplot,
        facet_group='SampleID',
        legend.position='inside',
        legend.position.inside=c(0.85, 0.70), # c(0,0) bottom left, c(1,1) top-right.
        scales='fixed',
        scale_mode='log10',
        facet_ncol=3
    )
```

# Plot heatmap of cis/trans interactions

```{r noncon_chr_mapping, include=FALSE}
# Count how many pairs of map to non-canonical chromosomes in the assembly
message('Print reads mapping to unused chromosomes')
pair.stats.list$chr.stats %>% 
    mutate(
        pair.types=
            case_when( 
                grepl('(_|EBV)', chr1) | grepl('(_|EBV)', chr2) ~ 'artifact',
                chr1 == chr2 ~ 'cis',
                chr1 != chr2 ~ 'trans'
            )
    ) %>%
    group_by(SampleID, pair.types) %>% 
    dplyr::summarize(sum=sum(value))
```
Get number of contacts between all pairs of chromosomes (intra & inter)
```{r cis_trans_plot_df, include=FALSE}
plot.df  <- 
    pair.stats.list$chr.stats %>% 
    rename('contacts'=value) %>% 
    # filter non-canonical chromosomes
    # filter( 
    #     if_all(
    #         starts_with('chr'),
    #         ~ !grepl('(_|EBV)', .x)
    #     )
    # ) %>% 
    mutate(
        across(
            starts_with('chr'),
            ~ factor(.x, levels=CHROMOSOMES)
        )
    ) %>% 
    group_by(SampleID) %>% 
    mutate(
        `% Total Contacts`=100 * (contacts / total.unique.contacts),
        `log10(Contacts)`=log10(contacts)
    ) %>%
    ungroup() %>% 
    pivot_longer(
        c(`% Total Contacts`, `log10(Contacts)`),
        names_to='metric',
        values_to='value'
    )
```
Plot all contacts between all chromosomes as heatmaps
```{r plot_cis_trans, results='asis', fig.height=6, fig.width=8}
plot.df %>% 
    get_info_from_SampleIDs(
        sample_ID_col='SampleID',
        keep_id=TRUE,
        nest_col=NA,
    ) %>% 
    filter(SampleID %in% samples.to.include | str_detect(SampleID, 'Merged')) %>% 
    make_nested_plot_tabs(
        group_cols=c('Celltype', 'Genotype', 'metric'),
        max_header_lvl=3,
        plot_fnc=plot_cistrans_chromosome_heatmap,
        fill_var='value',
        facet_group='SampleID'
    )
```

# Download Sample Stats

`.tsv` of stats per sample 
```{r download_stats}
make_summary_stats_table(
    min.resolutions,
    pair.stats.list,
    pairs.plot.df %>%
        select(-c(Edit, Celltype, Genotype, CloneID, TechRepID)),
) %>% 
filter(SampleID %in% samples.to.include | str_detect(SampleID, 'Merged')) %>% 
download_this(
    output_name="16p_HiC_Matrix_QCStats",
    button_type="default",
    output_extension=".csv",
    csv2=TRUE
)
```
