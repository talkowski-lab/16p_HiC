---
title: "QC stats for 16p HiC samples"
author: "Siddharth Reed"
date: "`r Sys.Date()`"
output: 
    html_document:
        toc: true
        toc_float: true
        theme: paper
        code_folding: hide
        df_print: paged
---
<style type="text/css">
.main-container {
  max-width: 1800px !important;
  margin-left: auto;
  margin-right: auto;
}
</style>

# Prepare data

Set up file locations
```{r results=FALSE}
library(here)
BASE_DIR=here()
source(file.path(BASE_DIR, 'scripts/locations.R'))
```
Load dependencies
```{r}
library(tidyverse)
library(magrittr)
source(file.path(BASE_DIR, 'scripts/utils.data.R'))
source(file.path(BASE_DIR, 'scripts/utils.qc.R'))
source(file.path(BASE_DIR, 'scripts/utils.plot.R'))
```
Load sample metadata
```{r message=FALSE, rows.print=5}
sample.metadata <- load_sample_metadata()
sample.metadata
```
Load output of `pairtools stats` 
```{r rows.print=5}
pair.stats.list <- load_pairtools_stats()
# pair.stats.list$general.stats
# pair.stats.list$distance.stats
# pair.stats.list$chr.stats
```
Load genome coverage from `cooltools coverage`
```{r rows.print=5, message=FALSE}
genome.coverage <- 
    check_cached_results( 
        results_file=NULL,
        force_redo=FALSE,
        return_data=TRUE,
        results_fnc=load_genome_coverage,
        weights=c('raw'),
        resolutions=c(5000, 10000, 25000)
    ) %>% 
    mutate(resolution=as.integer(resolution)) %>% 
    select(-c(filepath))
genome.coverage
```

# Calculate minimum resolution from pair orientations

The minimum usable resolution for a HiC dataset is defined in [Rao et al. 2014](https://www.cell.com/cell/fulltext/S0092-8674(14)01497-4?cc=y%3D) as follows

>We define the “matrix resolution” of a Hi-C map as the locus size used to construct a particular contact matrix and the “map resolution” as the smallest locus size such that 80% of loci have at least 1,000 contacts.

```{r, include=FALSE}
# Variables to count coverage across
grouping_cols <- 
    genome.coverage %>%
    colnames() %>%
    {.[!grepl("(start|end|coverage)", .)]}
# print(grouping_cols)
coverage.summary <- 
    genome.coverage %>%
    group_by(across(grouping_cols)) %>%
    summarize(
        bins.n.nz=sum(coverage > 0),
        bins.n.covered=sum(coverage > 1000),
        bins.n.total=n()
    ) %>%
    ungroup() %>%
    # Calculate totals by summing per chr values
    bind_rows(
        .,
        {.} %>%
        group_by(across(grouping_cols[!grepl("chr", grouping_cols)])) %>% 
        summarize(
            across(
                starts_with('bins.n.'),
                ~ sum(.x)
            )
        ) %>%
        add_column(chr='genome.wide')
    ) %>%
    mutate(
        bins.pct.nz=bins.n.nz / bins.n.total,
        bins.pct.covered=bins.n.covered / bins.n.total
    )
```
Now print all resolutions which are usable according to the Rao et al. 2014 definition
```{r paged.print=TRUE, max.print=10000}
coverage.summary %>% 
    filter(chr == 'genome.wide') %>%
    filter(weight == 'raw') %>% 
    filter(ReadFilter == 'mapq_30') %>% 
    filter(metric == 'cis') %>% 
    filter(bins.pct.covered >= 0.80) %>% 
    mutate(bins.pct.covered=sprintf("%0.1f%%", bins.pct.covered * 100)) %>% 
    select(
        Sample.ID,
        resolution,
        bins.n.covered,
        bins.n.total,
        bins.pct.covered
    ) %>%
    arrange(Sample.ID, resolution)
```

# Plot pair categories {.tabset}

## Plot pairs by distance

```{r include=FALSE}
plot.df <- 
    pair.stats.list$general.stats %>% 
    select(-c(category)) %>% 
    filter(stat %in% c('trans', 'cis')) %>% 
    dplyr::rename('interaction'=stat) %>% 
    add_column(range.start=0) %>% 
    bind_rows(pair.stats.list$distance.stats) %>% 
    mutate(
        range.end=ifelse(is.na(range.end), Inf, range.end),
        Category=
            case_when(
                orientation =='-+'   & range.end < 1001    ~ 'self-circle', 
                orientation =='+-'   & range.end < 1001    ~ 'dangling-end', 
                range.start >= 20000                       ~ 'Long.Range  >  20Kb',
                range.start >=  1000 & range.start < 20001 ~ 'Short.Range <= 20Kb',
                range.end   <=  1000                       ~ 'Too.Short   <=  1Kb',
                interaction == 'cis' & range.end == Inf    ~ 'Cis.Total',
                interaction == 'trans'                     ~ 'Trans',
            )
    ) %>%
    mutate(
        Category=
            factor(
                Category,
                levels=
                    c(
                        'self-circle', 
                        'dangling-end', 
                        'Too.Short   <=  1Kb',
                        'Short.Range <= 20Kb',
                        'Long.Range  >  20Kb',
                        'Cis.Total',
                        'Trans'
                    )
            )
    ) %>% 
    group_by(Sample.ID, Category) %>% 
    summarize(
        value=sum(value),
        # total per sample
        total.unique.contacts=unique(total.unique.contacts)
    ) %>% 
    ungroup() %>% 
    mutate(frac=100 * (value / total.unique.contacts))
```

```{r echo=FALSE, fig.align='center', fig.height=5}
plot.df %>% plot_qc_barplot(y_val='frac')
```

## Plot heatmap of cis/trans interactions

```{r, include=FALSE}
message('Print reads mapping to unused chromosomes')
pair.stats.list$chr.stats %>% 
    mutate(
        pair.types=
            case_when( 
                grepl('(_|EBV)', chr1) | grepl('(_|EBV)', chr2) ~ 'artifact',
                chr1 == chr2 ~ 'cis',
                chr1 != chr2 ~ 'trans'
            )
    ) %>%
    group_by(Sample.ID, pair.types) %>% 
    dplyr::summarize(sum=sum(value))
```

```{r, include=FALSE}
plot.df  <- 
    pair.stats.list$chr.stats %>% 
    rename('contacts'=value) %>% 
    filter( 
        if_all(
            starts_with('chr'),
            ~ !grepl('(_|EBV)', .x)
        )
    ) %>% 
    mutate(
        across(
            starts_with('chr'),
            ~ factor(.x, levels=CHROMOSOMES)
        )
    ) %>% 
    group_by(Sample.ID) %>% 
    mutate(
        `% Total Contacts`=100 * (contacts / total.unique.contacts),
        `log10(Contacts)`=log10(contacts)
    ) %>%
    ungroup() %>% 
    pivot_longer(
        c(`% Total Contacts`, `log10(Contacts)`),
        names_to='metric',
        values_to='value'
    )
```

```{r results='asis'}
tmp_plot <- function(plot.df){
    col_name <- plot.df$metric %>% unique() %>% first()
    plot.df %>%
    pivot_wider(
        names_from=metric,
        values_from=value
    ) %>% 
    plot_cistrans_chromosome_heatmap(fill_var=col_name)
}
plot.df %>% 
    filter(metric == "% Total Contacts") %>% 
    make_tab_per_group(
        group_col='Sample.ID',
        col_header=FALSE,
        max_lvl=3,
        plot_fnc=tmp_plot
    )
```
