---
title: "QC stats for 16p HiC samples"
author: "Siddharth Reed"
date: "`r Sys.Date()`"
---

<style type="text/css">
.main-container {
  <!-- max-width: 1800px !important; -->
  margin-left: auto;
  margin-right: auto;
}
</style>

# Dependencies + Load data

```{r knitr}
library(knitr)
knitr::opts_chunk$set(
    # eval=FALSE,
    results=FALSE,
    message=FALSE,
    warning=FALSE,
    dev=c('png', 'pdf', 'svg'),
    # dev=c('pdf'),
    dpi=300
)
```
Set up file locations + load dependencies
```{r dependencies, eval=TRUE}
library(here)
library(kableExtra)
here::i_am('notebooks/Matrix.QC.Rmd')
BASE_DIR <- here()
source(file.path(BASE_DIR, 'scripts', 'locations.R'))
source(file.path(SCRIPT_DIR, 'utils.data.R'))
source(file.path(BASE_DIR, 'scripts', 'constants.R'))
source(file.path(SCRIPT_DIR, 'utils.annotations.R'))
source(file.path(SCRIPT_DIR, 'utils.plot.R'))
source(file.path(SCRIPT_DIR, 'coverage', 'utils.coverage.R'))
source(file.path(SCRIPT_DIR, 'coverage', 'utils.qc.R'))
library(magrittr)
library(tidyverse)
```
Load sample metadata
```{r load_metadata, eval=TRUE}
sample.metadata.df <- 
    load_sample_metadata(filter=FALSE)
```
Load marginal coverage
```{r load_marginal_coverage_summary_stats}
coverage.summary <- 
    check_cached_results(
        results_file=RESOLTION_COVERAGE_SUMAMRY_FILE,
        # force_redo=TRUE,
        results_fnc=compute_all_coverage_summaries,
        resolutions=c(100, 50, 25, 10, 5) * 1e3   # Kbs
    ) %>%
    post_process_coverage_summaries(sample.metadata.df=sample.metadata.df) %>% 
    standardize_data_cols() %>% 
    pivot_wider(
        names_from='metric',
        values_from='value'
    ) %>% 
    # Pick relevant coverage results
    filter(chr == 'Genome.Wide') %>% 
    # format results for human readability
    mutate(`% Bins >= 1K`=sprintf("%0.1f%%", bins.pct.covered * 100)) %>% 
    mutate(is.valid.resolution=bins.pct.covered >= 0.80)
```
Load pairtools stats files
```{r pair_plot_df, eval=TRUE}
pair.stats.list <- 
    load_pairtools_stats()
pairs.plot.df <- 
    pair.stats.list %>%
    make_pair_qc_df() %>% 
    get_info_from_SampleIDs(include_merged_col=TRUE) %>%
    left_join(
        sample.metadata.df %>%
        select(SampleID, FlowcellID, Included),
        by=join_by(SampleID)
    ) %>%
    mutate(FlowcellID=ifelse(is.na(FlowcellID), 'Merged', FlowcellID))
```
Barplot theme
```{r theme obj, eval=TRUE}
barplot.ggtheme <- 
    make_ggtheme(
        legend.position='right',
        legend.text=element_text(size=5),
        legend.key.size=unit(10, "pt"),
        axis.text.x=element_text(size=4.5, angle=35, hjust=1),
        axis.title.x=element_blank()
    )
```

# Minimum Viable Resolution {.tabset}

The minimum usable resolution for a HiC dataset is defined in [Rao et al. 2014](https://www.cell.com/cell/fulltext/S0092-8674(14)01497-4?cc=y%3D) as follows

>We define the “matrix resolution” of a Hi-C map as the locus size used to construct a particular contact matrix and the “map resolution” as the smallest locus size such that 80% of loci have at least 1,000 contacts.

Now show which resolutions which are usable according to the Rao et al. 2014 definition
Heatmap of valid resolutions

## Merged {.tabset}

```{r min_res_heatmap_merged, results='asis', fig.dim=c(8,6)}
coverage.summary %>% 
    filter(isMerged == 'Merged') %>% 
    make_nested_plot_tabs(
        group.cols=c('weight'),
        max.header.lvl=3,
        plot.fnc=plot_heatmap,
        x.var='resolution',
        y.var='SampleID',
        fill.var='is.valid.resolution',
        facet.row='Celltype',
        label.var='% Bins >= 1K',
        label.size=5,
        scales='free',
        legend.position='top',
        axis.title.y=element_blank(),
        axis.text.x=element_text(angle=45, hjust=1)
    )
```

## Individual {.tabset}

```{r min_res_heatmap_indv, results='asis', fig.dim=c(12,9)}
coverage.summary %>% 
    filter(isMerged == 'Individual') %>% 
    # count(SampleID, resolution)
    make_nested_plot_tabs(
        group.cols=c('weight'),
        max.header.lvl=3,
        plot.fnc=plot_heatmap,
        x.var='resolution',
        y.var='SampleID',
        fill.var='is.valid.resolution',
        facet.row='Celltype',
        label.var='% Bins >= 1K',
        label.size=3,
        scales='free',
        legend.position='top',
        axis.title.y=element_blank(),
        axis.text.x=element_text(angle=45, hjust=1)
    )
```

# Plot pairs by distance {.tabset}

## Number of pairs 

```{r plot_n_pairs, fig.dim=c(7,5)}
pairs.plot.df %>% 
    filter(Included | isMerged == 'Merged') %>% 
    dplyr::rename('Unique Pairs'=value) %>% 
    plot_barplot(
        x.var='Category',
        y.var='Unique Pairs',
        fill.var='SampleID',
        facet.col='Celltype',
        facet.row='isMerged',
        x.scale.mode='discrete',
        y.scale.mode='log10',
        legend.cols=2,
        scales='free_y',
        y.limits=c(1e6, NA),
        theme.obj=barplot.ggtheme
    )
```

## % of pairs 

```{r plot_pct_pairs, fig.dim=c(7,5)}
pairs.plot.df %>% 
    filter(Included | isMerged == 'Merged') %>% 
    dplyr::rename('Unique Pairs'=frac) %>% 
    plot_barplot_with_threshold_lines(
        # normal barplot arguments
        x.var='Category',
        y.var='Unique Pairs',
        fill.var='SampleID',
        facet.col='Celltype',
        facet.row='isMerged',
        x.scale.mode='discrete',
        y.scale.mode='pct',
        theme.obj=barplot.ggtheme,
        legend.cols=2,
        # where to draw lines
        scales='free_y',
        lines.df=
            tribble(
                ~Category, ~y_lower, ~y_upper,
                'Long Range  >  20Kb', 0.15, 0.40
            )
    )
```

## % of pairs  (by batch) {.tabset}

```{r plot_pct_pairs_batch, results='asis', fig.dim=c(10, 6)}
pairs.plot.df %>% 
    dplyr::rename('Unique Pairs'=frac) %>% 
    # filter(FlowcellID == 'Merged', isMerged == 'Individual') %>% 
    # dplyr::count(FlowcellID, isMerged)
    make_nested_plot_tabs(
        plot.fnc=plot_barplot_with_threshold_lines,
        group.cols=c('isMerged'),
        max.header.lvl=3,
        # normal barplot arguments
        x.var='Category',
        y.var='Unique Pairs',
        fill.var='SampleID',
        facet.col='FlowcellID',
        facet.row='Celltype',
        x.scale.mode='discrete',
        y.scale.mode='pct',
        theme.obj=barplot.ggtheme,
        legend.cols=1,
        # where to draw lines
        scales='free_y',
        lines.df=
            tribble(
                ~Category, ~y_lower, ~y_upper,
                'Long Range  >  20Kb', 0.15, 0.40
            )
    )
```

# Plot heatmap of cis/trans interactions {.tabset}

```{r noncon_chr_mapping, include=FALSE}
# Count how many pairs of map to non-canonical chromosomes in the assembly
message('Print reads mapping to unused chromosomes')
pair.stats.list$chr.stats %>% 
    mutate(
        pair.types=
            case_when( 
                grepl('(_|EBV)', chr1) | grepl('(_|EBV)', chr2) ~ 'artifact',
                chr1 == chr2 ~ 'cis',
                chr1 != chr2 ~ 'trans'
            )
    ) %>%
    group_by(SampleID, pair.types) %>% 
    dplyr::summarize(sum=sum(value))
```
Get number of contacts between all pairs of chromosomes (intra & inter)
```{r cis_trans_plot_df, include=FALSE}
plot.df  <- 
    pair.stats.list$chr.stats %>% 
    dplyr::rename('contacts'=value) %>% 
    mutate(
        across(
            starts_with('chr'),
            ~ factor(.x, levels=CHROMOSOMES)
        )
    ) %>% 
    group_by(SampleID) %>% 
    mutate(
        `Total Contacts`=contacts,
        `% Total Contacts`=100 * (contacts / total.unique.contacts),
        `log10(Contacts)`=log10(contacts)
    ) %>%
    ungroup() %>% 
    pivot_longer(
        c(`% Total Contacts`, `log10(Contacts)`, `Total Contacts`),
        names_to='metric',
        values_to='value'
    ) %>% 
    get_info_from_SampleIDs(
        sample_ID_col='SampleID',
        include_merged_col=TRUE,
        keep_id=TRUE,
        nest_col=NA
    )
```
Plot all contacts between all chromosomes as heatmaps
```{r plot_cis_trans, results='asis', fig.dim=c(10,10)}
plot.df %>% 
    make_nested_plot_tabs(
        group.cols=c('isMerged', 'Genotype', 'metric'),
        max.header.lvl=2,
        plot.fnc=plot_heatmap,
        x.var='chr1',
        y.var='chr2',
        fill.var='value',
        facet.group='SampleID',
        scales='fixed',
        axis.text.x=element_text(angle=45, hjust=1),
        legend.position='top',
        legend.text=element_text(angle=45, hjust=1),
        plot.elements=
            list(
                scale_fill_continuous(
                    labels=scales::label_number(scale_cut=scales::cut_short_scale())
                ),
                scale_fill_gradient(
                    low='grey90',
                    high='red'
                ),
                theme(axis.title=element_blank())
            )
    )
```

# Plot read orientation frequency over distance {.tabset}

Recreating Figure 1 from the [ENCODE HiC Guidelines](https://www.encodeproject.org/documents/75926e4b-77aa-4959-8ca7-87efcba39d79/).
First format all the orientation data
```{r pair_orientation_df}
pair.orientation.df <- 
    pair.stats.list$distance.stats %>% 
    mutate(
        range.end=
            ifelse(
                is.na(range.end), 
                range.start+1,
                range.end
            )
    ) %>% 
    mutate(
        orientation=
            orientation %>%
            str_replace_all(fixed('+'), '>') %>% 
            str_replace_all(fixed('-'), '<')
    ) %>% 
    get_info_from_SampleIDs(include_merged_col=TRUE)
        
```
Now plot distance vs # of pairs for each pair orientation
```{r plot_pair_orientation, results='asis', fig.dim=c(11,10)}
pair.orientation.df %>% 
    filter(interaction == 'cis') %>% select(-c(interaction)) %>%
    filter(value > 0) %>% 
    make_nested_plot_tabs(
        plot.fnc=plot_pair.orientation_lineplot,
        group.cols=c('isMerged', 'Genotype'),
        facet.group='SampleID',
        facet.ncol=3,
        x.scale.mode='log10',
        y.scale.mode='log10',
        # legend.position='inside',
        # legend.position.inside=c(0.85, 0.20),
        scales='fixed'
    )
```

# Download Sample Stats

`.tsv` of stats per sample 
```{r download_stats, eval=FALSE}
library(downloadthis)
min.resolutions <- 
    coverage.summary %>% 
    mutate(resolution=scale_numbers(resolution, force_numeric=TRUE)) %>% 
    pivot_wider(
        names_from='metric',
        values_from='value'
    ) %>% 
    # Pick relevant coverage results
    filter(
        chr == 'Genome.Wide',
        bins.pct.covered >= 0.80
    ) %>% 
    # Pick smallest resolution with sufficient coverage
    group_by(SampleID) %>% 
    slice_min(resolution, n=1) %>% 
    ungroup() %>% 
    # format results for human readability
    mutate(bins.pct.covered=sprintf("%0.1f%%", bins.pct.covered * 100)) %>% 
    arrange(SampleID) %T>%
    write_tsv(MIN_SAMPLE_RESOLUTION_FILE) %>% 
    # mutate(resolution=scale_numbers(resolution)) %>% 
    dplyr::rename(
        'Min. Viable Resolution'=resolution, 
        '# Total Bins'=bins.n.total,
        '# Bins > 0'=bins.n.nz,
        '% Bins > 0'=bins.pct.nz,
        '# Bins >= 1K'=bins.n.covered,
        '% Bins >= 1K'=bins.pct.covered,
    )
make_summary_stats_table(
    min.resolutions,
    pair.stats.list,
    pairs.plot.df %>%
        select(-c(Edit, Celltype, Genotype, CloneID, TechRepID)),
) %>% 
download_this(
    output_name="16p_HiC_Matrix_QCStats",
    button_type="default",
    output_extension=".csv",
    csv2=TRUE
)
```

# RPRR 2026 Figure {.tabset} 

```{r rprr_2026, fig.dim=c(6,4), eval=FALSE}
txt.size=10
pairs.plot.df %>% 
    # filter(Included | isMerged == 'Merged') %>% 
    filter(isMerged == 'Merged') %>% 
    dplyr::rename('Unique Pairs'=frac) %>% 
    mutate(SampleID=str_remove(SampleID, '.Merged.Merged')) %>% 
    plot_barplot_with_threshold_lines(
        # normal barplot arguments
        x.var='Category',
        y.var='Unique Pairs',
        fill.var='SampleID',
        facet.col='Celltype',
        facet.row='isMerged',
        x.scale.mode='discrete',
        y.scale.mode='pct',
        theme.obj=barplot.ggtheme,
        legend.cols=1,
        # where to draw lines
        scales='free_y',
        lines.df=
            tribble(
                ~Category, ~y_lower, ~y_upper,
                'Long Range  >  20Kb', 0.15, 0.40
            )
    ) +
    theme(
        strip.text=element_text(size=txt.size),
        axis.text.x=element_text(size=txt.size, angle=45),
        axis.text.y=element_text(size=txt.size),
        legend.text=element_text(size=txt.size),
        legend.title=element_blank()
    )
```
